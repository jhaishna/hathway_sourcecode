/**********************************************************************
 *
 * Copyright (c) 1999, 2009, Oracle and/or its affiliates.All rights reserved. 
 *      
 *      This material is the confidential property of Oracle Corporation
 *      or its licensors and may be used, reproduced, stored or transmitted
 *      only in accordance with a valid Oracle license or sublicense agreement.
 *
 **********************************************************************/

#ifndef lint
static char Sccs_id[] = "@(#)$Id: fm_subscription_pol_spec_cycle_fee_interval.c /cgbubrm_7.3.2.rwsmod/1 2009/03/24 07:02:26 amamidi Exp $";
#endif

/*******************************************************************
 * Contains the PCM_OP_SUBSCRIPTION_POL_SPEC_CYCLE_FEE_INTERVAL operation. 
 *******************************************************************/

#include <stdio.h> 
#include <string.h> 
 
#include "pcm.h"
#include "ops/bill.h"
#include "ops/subscription.h"
#include "ops/bal.h"
#include "pin_bill.h"
#include "pin_rate.h"
#include "cm_fm.h"
#include "pin_errs.h"
#include "pinlog.h"
#include "mso_ops_flds.h"
#include "mso_cust.h"
#include "mso_prov.h"
#include "fm_bal.h"

#define POSTPAID 0
#define ADVANCE  1
#define PREPAID	 2
#define CATV_PREPAID 1


int postpaid_grants_priorities[13] = {510,540,570,600,630,660,690,720,750,780,810,840};

/*******************************************************************
 * Routines contained within.
 *******************************************************************/
EXPORT_OP void
op_subscription_pol_spec_cycle_fee_interval(
	cm_nap_connection_t	*connp,
	int32			opcode,
	int32			flags,
	pin_flist_t		*i_flistp,
	pin_flist_t		**r_flistpp,
	pin_errbuf_t		*ebufp);

static void
fm_subscription_pol_spec_cycle_fee_interval(
	cm_nap_connection_t     *connp,
	pcm_context_t		*ctxp,
	cm_op_info_t		*opstackp,
	int32			flags,
	pin_flist_t		*i_flistp,
	pin_flist_t		**r_flistpp,
	pin_errbuf_t		*ebufp);

static void 
mso_fm_cycle_fee_evt_type(
	pcm_context_t		*ctxp,
	char			*event_type, 
	time_t			*charged_from_t,
	time_t			*charged_to_t,
	int32			is_charged_t_bdom,
	pin_errbuf_t		*ebufp);

static int32 
fm_mso_modify_for_mcf(
	pcm_context_t		*ctxp,
	pin_flist_t		**i_flistp,
	cm_op_info_t		*opstackp,
	pin_errbuf_t		*ebufp);

void read_prod_details(pcm_context_t		*ctxp,
		pin_flist_t		*i_flistp,
		pin_flist_t		**prod_flistp,
		pin_errbuf_t		*ebufp);

void fm_mso_update_service_fup_status(
		cm_nap_connection_t     *connp,
		pcm_context_t		*ctxp,
		pin_flist_t		*i_flistp,
		pin_flist_t		*prod_details_flistp,
		char			*event_type,
		cm_op_info_t		*opstackp,
		pin_flist_t		*r_flistp,
		pin_errbuf_t		*ebufp);

void create_lifecycle_event(
		pcm_context_t		*ctxp,
		pin_flist_t		*i_flistp,
		pin_flist_t		*prod_details_flistp,
		pin_errbuf_t		*ebufp);

int32 get_bill_when_from_service(
		pcm_context_t		*ctxp,
		poid_t			*svc_pdp,
		pin_errbuf_t		*ebufp);


void fm_mso_set_charged_to_t(
		pcm_context_t		*ctxp,
		pin_flist_t		*i_flistp,
		pin_flist_t		**r_flistpp,
		cm_op_info_t		*opstackp,
		pin_errbuf_t		*ebufp);


static void mso_cust_renew_quota(
		pcm_context_t		*ctxp,
		poid_t		*acct_pdp,
		char		*action,
		poid_t		*svc_pdp,
		poid_t		*p_pdp,
		int32             flag,
		pin_flist_t	*r_flistp,
		pin_errbuf_t		*ebufp);

int is_autorenew_flow(
		cm_nap_connection_t     *connp,
		cm_op_info_t *opstackp,
		pin_errbuf_t     *ebufp);

static void 
update_for_topup(	
		pcm_context_t	*ctxp, 
		cm_op_info_t	*opstackp,
		char		*event_type,
		pin_flist_t	*i_flistp, 
		pin_flist_t	**r_flistpp, 
		pin_errbuf_t	*ebufp);

static void
fm_mso_cust_bb_hw_amc_get_cycle_details(
        pcm_context_t   *ctxp,
        pin_flist_t      *i_flistp,
        pin_errbuf_t    *ebufp);

static void
get_last_plan_valid_to_fup(
	pcm_context_t           *ctxp,
	poid_t                  *acc_obj,
	poid_t                  *svc_obj,
	time_t			*fup_valid_to,
	pin_errbuf_t            *ebufp);
	
extern int32
fm_mso_get_product_priority(
        pcm_context_t           *ctxp,
        poid_t                  *prod_pdp,
        pin_flist_t             **ret_flistpp,
        pin_errbuf_t            *ebufp);

extern void
fm_mso_prov_update_product_cycle_fee_charge_dates(
        pcm_context_t   *ctxp,
        poid_t          *acct_pdp,
        poid_t          *service_obj,
        poid_t          *offering_obj,
        pin_flist_t     **ret_flistpp,
        pin_errbuf_t    *ebufp);

PIN_IMPORT int32
fm_mso_catv_pt_pkg_type(
        pcm_context_t           *ctxp,
        poid_t                  *prd_pdp,
        pin_errbuf_t            *ebufp);

/*******************************************************************
 * Main routine for the PCM_OP_SUBSCRIPTION_POL_SPEC_CYCLE_FEE_INTERVAL operation.
 *******************************************************************/
void
op_subscription_pol_spec_cycle_fee_interval(
	cm_nap_connection_t	*connp,
	int32			opcode,
	int32			flags,
	pin_flist_t		*i_flistp,
	pin_flist_t		**r_flistpp,
	pin_errbuf_t		*ebufp)
{
	void			*vp = NULL;

	pcm_context_t		*ctxp = connp->dm_ctx;
	cm_op_info_t		*opstackp = connp->coip;

	*r_flistpp = NULL;
	if (PIN_ERR_IS_ERR(ebufp)) {
		return;
	}
	PIN_ERR_CLEAR_ERR(ebufp);

	/*
	 * Insanity check.
	 */
	if (opcode != PCM_OP_SUBSCRIPTION_POL_SPEC_CYCLE_FEE_INTERVAL) {
		pin_set_err(ebufp, PIN_ERRLOC_FM,
			PIN_ERRCLASS_SYSTEM_DETERMINATE,
			PIN_ERR_BAD_OPCODE, 0, 0, opcode);
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR,
			"op_subscription_pol_spec_cycle_fee_interval bad opcode error", 
			ebufp);
		return;
	}

	/*
	 * Debug: What we got.
	 */
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
		"op_subscription_pol_spec_cycle_fee_interval input flist", i_flistp);

	/*
	 * Prepare return flist.
	 */
        *r_flistpp = PIN_FLIST_CREATE(ebufp);
        vp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_POID, 0, ebufp);
        PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_POID, vp, ebufp);

        vp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_FROM_T,
                0, ebufp);
        PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_FROM_T,
                vp, ebufp);
        vp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_TO_T,
                0, ebufp);
        PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_TO_T,
                vp, ebufp);
        vp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_SCALE, 1, ebufp);
        if (vp) {
                PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_SCALE,
                                                vp, ebufp); 
	}
        /*
	 * Error?
	 */

	 if (PIN_ERR_IS_ERR(ebufp)) {
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR,
		"op_subscription_pol_spec_cycle_fee_interval error", ebufp);
		return;
	}

	/* calling facility function*/

	//fm_subscription_pol_spec_cycle_fee_interval(ctxp, opstackp, flags, i_flistp, r_flistpp, ebufp); 
	fm_subscription_pol_spec_cycle_fee_interval(connp, ctxp, opstackp, flags, i_flistp, r_flistpp, ebufp);


	/* Set the FUP_STATUS to BEFORE_FUP for FUP products here */

	if (PIN_ERR_IS_ERR(ebufp)) {
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR,
		"op_subscription_pol_spec_cycle_fee_interval error", ebufp);
	} else {

		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
		"op_subscription_pol_spec_cycle_fee_interval output flist", *r_flistpp);
	}
	return;
}

/*******************************************************************
 * This is the custom implementation for this policy
 *******************************************************************/
static void 
fm_subscription_pol_spec_cycle_fee_interval(
	cm_nap_connection_t     *connp,
	pcm_context_t		*ctxp,
	cm_op_info_t		*opstackp,
	int32			flags,
	pin_flist_t		*i_flistp,
	pin_flist_t		**r_flistpp,
	pin_errbuf_t		*ebufp)
{
	pin_flist_t		*readproduct_inflistp = NULL;
	pin_flist_t		*readproduct_outflistp = NULL;
	pin_flist_t		*args_flistp = NULL;
	pin_flist_t		*prod_details_flistp = NULL;
	pin_flist_t		*ppo_iflistp = NULL;
	pin_flist_t		*ppo_oflistp = NULL;

	poid_t			*product_poid = NULL;
	poid_t			*svc_pdp = NULL;
    poid_t          *pdt_pdp = NULL;
	
	char			*event_type = NULL;
	char			*svc_type = NULL;
	
	int			csr_access = 0;
	int			acct_update = 0;
	int32			modify = 0;

	time_t			*charged_from_t = NULL;
	time_t			*charged_to_t = NULL;
	time_t			*ppo_cet = NULL;
	time_t			*actg_next_t = NULL;
	int32			charged_day = 0;
	int32			actg_cycle_dom = 0;
	int32			is_charged_t_bdom = 0;
    int32			is_base_pack = -1;
	char			buf[60];	
	time_t			current_time = 0;
	char			*action = NULL;
	time_t			chrg_from = 0;	
	struct tm       	*timeeff;
	if (PIN_ERR_IS_ERR(ebufp))
		return;
	PIN_ERR_CLEAR_ERR(ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval input flist", i_flistp);	
	
	product_poid = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_PRODUCT_OBJ, 1, ebufp);
	if (!product_poid)
	{	
		return;
	}	
	
	/*******************************************************************
	* Read product for the event type
	*******************************************************************/

	readproduct_inflistp = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_SET(readproduct_inflistp, PIN_FLD_POID, product_poid, ebufp );
	args_flistp = PIN_FLIST_ELEM_ADD(readproduct_inflistp, PIN_FLD_USAGE_MAP, PIN_ELEMID_ANY, ebufp );
	PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_EVENT_TYPE, NULL, ebufp );

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval read product input list", readproduct_inflistp);
	PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, readproduct_inflistp, &readproduct_outflistp, ebufp);
	PIN_FLIST_DESTROY_EX(&readproduct_inflistp, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_READ_FLDS", ebufp);
		PIN_ERR_CLEAR_ERR(ebufp);
		PIN_FLIST_DESTROY_EX(&readproduct_outflistp, NULL);	
		return;
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval read product output flist", readproduct_outflistp);
	
	args_flistp = PIN_FLIST_ELEM_GET(readproduct_outflistp, PIN_FLD_USAGE_MAP, 0, 1, ebufp );
	if (args_flistp)
	{
		event_type = PIN_FLIST_FLD_GET(args_flistp, PIN_FLD_EVENT_TYPE, 1, ebufp );
	}
	
 	/*******************************************************************
	* Modify Dates for Advanced Charging
	*******************************************************************/
	if(strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_grant") != 0) {
	    PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_EVENT_TYPE, event_type, ebufp);		
	    modify = fm_mso_modify_for_mcf(ctxp, &i_flistp, opstackp,  ebufp);
	} else {
		fm_mso_set_charged_to_t(ctxp, i_flistp, r_flistpp, opstackp, ebufp);
	} 
	//    modify = fm_mso_modify_for_mcf(ctxp, &i_flistp, opstackp,  ebufp);
	if (modify)
	{
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf return 1");
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CYCLE_FEE_END_T, *r_flistpp, PIN_FLD_CYCLE_FEE_END_T, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CHARGED_TO_T,    *r_flistpp, PIN_FLD_CHARGED_TO_T, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_ACTG_NEXT_T,     *r_flistpp, PIN_FLD_ACTG_NEXT_T, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_ACTG_FUTURE_T,   *r_flistpp, PIN_FLD_ACTG_FUTURE_T, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CYCLE_FEE_START_T,  *r_flistpp, PIN_FLD_CYCLE_FEE_START_T, ebufp);
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "op_subscription_pol_spec_cycle_fee_interval modified input flist", i_flistp);


	if ((event_type) && ((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_sb_adn_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_sb_adn_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_sb_adn_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_sb_adn_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_sb_adn_fdp") == 0) 

		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_sb_alc_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_sb_pkg_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_sb_alc_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_sb_pkg_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_sb_alc_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_sb_pkg_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_sb_alc_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_sb_pkg_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_sb_alc_fdp") == 0)
		|| (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_sb_pkg_fdp") == 0)

		|| ((strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental")) == 0) &&
			/* below has been added to not to allow the catv flow to enter through this condition */
			(strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental") != 0))
		
		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental")) == 0)

		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental")) == 0)

		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental")) == 0)

		/*|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc")) == 0)
		
		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc")) == 0)
		
		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc")) == 0)
		
		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc")) == 0) */


		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_monthly_fdp")) == 0)

		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp")) == 0)

		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp")) == 0)

		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual_fdp",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_annual_fdp")) == 0)

		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp")) == 0)

		|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp",	
			strlen("/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp")) == 0)
                /* AMC EVENTS CM AND DCM START*/
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/cm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/cm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/cm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/cm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/cm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/cm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/cm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/cm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/cm/pre",
                      strlen("/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/cm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/cm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/cm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/dcm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/dcm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/dcm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/dcm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/dcm/pre",
                         strlen("/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/dcm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/dcm/pre",
                         strlen("/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/dcm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/dcm/pre",
                      strlen("/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/dcm/pre")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/dcm/pre",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/dcm/pre")) == 0)
                /* AMC EVENTS CM AND DCM END */
		/**** Pavan Bellala 21-09-2015 *******
		Added Additional IP Plan events 
		**************************************/
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/ip",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/ip")) == 0)
		/**** Pavan Bellala 14-10-2015 ****************
		Added Additional IP Plan events for all cycles
		***********************************************/
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/ip",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/ip")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/ip",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/ip")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/ip",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/ip")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/ip",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/ip")) == 0)
                || (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/ip",
                        strlen("/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/ip")) == 0)
	   )) 
	{
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, event_type);
		charged_from_t = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_FROM_T, 1, ebufp);
		charged_to_t = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_TO_T, 1, ebufp);

		if (charged_from_t && charged_to_t)
		{
			charged_day = (localtime(charged_from_t))->tm_mday;
			actg_next_t = PIN_FLIST_FLD_GET(i_flistp,PIN_FLD_ACTG_NEXT_T,0, ebufp);
			actg_cycle_dom = (localtime(actg_next_t))->tm_mday;
			if(charged_day == actg_cycle_dom) {
			    is_charged_t_bdom = 1;
			}
			
			if (!fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_SUSPEND_SERVICE) && !fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_HOLD_SERVICE))
			{
			   /*** Added PIN_FLD_ACTION in input for UNHOLD cases to reset FUP***/
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,"not calling for suspend service or hold service");
				action = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_ACTION, 1, ebufp);
				if(action != NULL)
				{
					if(strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_grant") == 0)
					{
						charged_from_t = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_FROM_T, 1, ebufp);
						current_time = pin_virtual_time(NULL);
						if(charged_from_t && *charged_from_t <= current_time )
						{
							PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "inside change dates");
							mso_fm_cycle_fee_evt_type(ctxp, event_type, charged_from_t, charged_to_t, is_charged_t_bdom, ebufp);
						}
						else
						{
							timeeff = localtime(charged_from_t);
							timeeff->tm_mon = timeeff->tm_mon - 1;
							chrg_from = mktime (timeeff);
							PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CHARGED_FROM_T, i_flistp, PIN_FLD_CHARGED_TO_T, ebufp);
							charged_to_t = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_TO_T, 1, ebufp);
							PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_FROM_T, &chrg_from, ebufp);
							PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_FROM_T, &chrg_from, ebufp);
							PIN_FLIST_FLD_DROP(i_flistp, PIN_FLD_ACTION, ebufp);
							PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "outside change dates");
						}
					}
				}
				else
				{
			   		mso_fm_cycle_fee_evt_type(ctxp, event_type, charged_from_t, charged_to_t, is_charged_t_bdom, ebufp);
				}
			 }


			ppo_iflistp = PIN_FLIST_CREATE(ebufp);
			PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_OFFERING_OBJ, ppo_iflistp, PIN_FLD_POID, ebufp);
			PIN_FLIST_FLD_SET(ppo_iflistp, PIN_FLD_SERVICE_OBJ, NULL, ebufp);
			PIN_FLIST_FLD_SET(ppo_iflistp, PIN_FLD_CYCLE_END_T, NULL, ebufp);


			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Purchase product read flds input flist", ppo_iflistp);
    			PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, ppo_iflistp, &ppo_oflistp, ebufp);
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Purchase product read flds output flist", ppo_oflistp);

			ppo_cet = PIN_FLIST_FLD_GET(ppo_oflistp, PIN_FLD_CYCLE_END_T, 1, ebufp);
			svc_pdp = PIN_FLIST_FLD_GET(ppo_oflistp, PIN_FLD_SERVICE_OBJ, 0, ebufp);
			svc_type = (char *)PIN_POID_GET_TYPE(svc_pdp);
			
		//	if((ppo_cet != NULL) && (*ppo_cet != 0) && (strcmp(svc_type,"/service/telco/broadband") == 0)) {
			if((ppo_cet != NULL) && (*ppo_cet != 0) ) 
			{
				if(*ppo_cet < *charged_to_t)
				 {
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Resetting charged_to_t to cycle_end_t");
				    	*charged_to_t = *ppo_cet;
				}
			}

			/*CHECK AMC EVENT AND SET CHARGED_TO FOR PREPAID SCENARIOS*/
			if((ppo_cet != NULL) && (*ppo_cet != 0) && strstr(event_type, AMC_EVENT) && (!strstr(event_type, "post")))
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " AMC CHANGES Resetting charged_to_t to cycle_end_t");
				*charged_to_t = *ppo_cet;
			}

			//Added for preventing CATV FDP products getting renewed 	
			if(!((strcmp(svc_type,"/service/catv") == 0) && fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_REACTIVATE_SERVICE)))
			{
				sprintf(buf,"service_type %s opcode : %d",svc_type, fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_REACTIVATE_SERVICE));
				PIN_ERR_LOG_MSG(3,buf);
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_END_T, charged_to_t, ebufp );
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_TO_T, charged_to_t, ebufp );
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval entering block", i_flistp);
				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_TO_T, charged_to_t, ebufp );
				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_END_T, charged_to_t, ebufp );
			}
			// Added for preventing refund/charging for FDP products in catv
			sprintf(buf,"service_type %s opcode : %d",svc_type, fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_REACTIVATE_SERVICE));
			PIN_ERR_LOG_MSG(3,buf);		
			if( (strcmp(svc_type,"/service/catv") == 0) && 
			(fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_REACTIVATE_SERVICE) || fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_SUSPEND_SERVICE)))
			{

				PIN_ERR_LOG_MSG(3,"Entering suspension/Reactivation case");
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval entering react/susp block", *r_flistpp);
				charged_to_t = PIN_FLIST_FLD_GET(*r_flistpp,PIN_FLD_CHARGED_TO_T,1,ebufp);
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_START_T, charged_to_t, ebufp );
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_FROM_T, charged_to_t, ebufp );
        	    PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval entering block", i_flistp);
	            PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_FROM_T, charged_to_t, ebufp );
        	    PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_START_T, charged_to_t, ebufp );
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval entering  react/susp block iflist", i_flistp);
			}
			
			// Added for preventing refund/charging for FDP products in catv from Cancellation
			sprintf(buf,"service_type %s opcode : %d",svc_type, fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_CANCEL_PLAN));
			PIN_ERR_LOG_MSG(3,buf);		
			if( (strcmp(svc_type,"/service/catv") == 0) && 
			(fm_utils_op_is_ancestor(connp->coip, MSO_OP_CUST_CANCEL_PLAN)))
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Entering Cancel Plan case");
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval entering cancel block", *r_flistpp);

                pdt_pdp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_PRODUCT_OBJ, 1, ebufp);
                if (pdt_pdp)
                {
                    is_base_pack = fm_mso_catv_pt_pkg_type(ctxp, pdt_pdp, ebufp);
                    if (is_base_pack != 0 )
                    {
                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Non-Base Pack Cancellation" );
        				charged_to_t = PIN_FLIST_FLD_GET(*r_flistpp, PIN_FLD_CHARGED_TO_T, 1, ebufp);
        				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_START_T, charged_to_t, ebufp );
		    	    	PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_FROM_T, charged_to_t, ebufp );
        	            PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "first set update", i_flistp);
        	            PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_FROM_T, charged_to_t, ebufp );
                	    PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_START_T, charged_to_t, ebufp );
				        PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "after cancel block update: iflist", i_flistp);

                    }
                    else
                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Base Pack Cancellation" );
                }
                
			}

			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval after changing input flist", i_flistp);
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_subscription_pol_spec_cycle_fee_interval r_flistpp", *r_flistpp);
		}
	}

	if(event_type && !strstr(event_type, AMC_EVENT))
	{
		update_for_topup(ctxp, opstackp, event_type, i_flistp, r_flistpp, ebufp);
	}

	/* Set the FUP_STATUS to BEFORE_FUP for FUP products here */
	read_prod_details(ctxp, i_flistp, &prod_details_flistp, ebufp);
	//fm_mso_update_service_fup_status(ctxp, i_flistp, prod_details_flistp, event_type, opstackp, ebufp);
	fm_mso_update_service_fup_status(connp, ctxp, i_flistp, prod_details_flistp, event_type, opstackp, *r_flistpp,  ebufp);
	//create_lifecycle_event(ctxp, i_flistp, prod_details_flistp, ebufp);
	PIN_FLIST_DESTROY_EX(&readproduct_outflistp, NULL);
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Returning from fm_subscription_pol_spec_cycle_fee_interval after changing input flist");
	return;
}

static void 
update_for_topup(
	pcm_context_t	*ctxp, 
	cm_op_info_t	*opstackp,
	char		*event_type,
	pin_flist_t	*i_flistp, 
	pin_flist_t	**r_flistpp, 
	pin_errbuf_t	*ebufp)
{
	int32		stack_opcode = 0;
	int32		initial_opcode = 0;
	char		debug_msg[250];
	char		*program_name = NULL;
	char            *action = NULL;
	pin_flist_t	*initial_flistp = NULL;
	pin_flist_t	*pp_read_iflistp = NULL;
	pin_flist_t	*pp_read_oflistp = NULL;
	int32		is_topup = 0;
	int32		bill_when = 0;
	int32		fup_plan = 0;
	struct tm       *timeeff;
	time_t		*purchase_end_t = 0;
	time_t		charged_from_t = 0;
	time_t		charged_to_t = 0;
	poid_t		*service_pdp = NULL;
	poid_t		*prod_pdp = NULL;
	poid_t		*acc_pdp = NULL;
	pin_decimal_t	*prod_priority = NULL;
	double		prod_priority_double = 0;
	pin_flist_t	*readproduct_inflistp = NULL;
	pin_flist_t	*readproduct_outflistp = NULL;

	int32		is_add_mb = 0;


	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Entered update_for_topup ");
    while(opstackp != NULL)
    {
		stack_opcode = opstackp->opcode;
		sprintf(debug_msg, "OPCODE=%d", stack_opcode);
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, debug_msg);
		
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,"BEFORE PCM_OP_ACT_USAGE FLIST", opstackp->in_flistp);
		initial_flistp = opstackp->in_flistp;
		initial_opcode = opstackp->opcode;
		
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,"Intial opcode input FLIST", initial_flistp);
		if ((initial_opcode == MSO_OP_PROV_BB_PROCESS_RESPONSE))
		{
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,"MSO_OP_PROV_BB_PROCESS_RESPONSE input FLIST",initial_flistp);
			action = PIN_FLIST_FLD_GET(initial_flistp, PIN_FLD_ACTION, 0, ebufp);
			program_name = PIN_FLIST_FLD_GET(initial_flistp, PIN_FLD_PROGRAM_NAME, 0, ebufp);
			if((action) && (strstr(action, "TOPUP_WO_PLAN") ||
				strstr(action, "ACTIVATION") ||
				strstr(action, "CHANGE PLAN") ||
				strstr(action, "ADD PLAN")))
			{
				is_topup = 1;
				break;
			}
			//Added else condition for Add MB/GB
			else if((action) && strstr(action, "ADD_DATA_DOCSIS"))
			{
				is_add_mb = 1;
				break;
			}

		}
		opstackp = opstackp->next;
    }

	if(is_topup || is_add_mb) {
		pp_read_iflistp = PIN_FLIST_CREATE(ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_OFFERING_OBJ, pp_read_iflistp, PIN_FLD_POID, ebufp);
		PIN_FLIST_FLD_SET(pp_read_iflistp, PIN_FLD_PURCHASE_END_T, NULL, ebufp);
		PIN_FLIST_FLD_SET(pp_read_iflistp, PIN_FLD_SERVICE_OBJ, NULL, ebufp);
		PIN_FLIST_FLD_SET(pp_read_iflistp, PIN_FLD_ACCOUNT_OBJ, NULL, ebufp);
		PIN_FLIST_FLD_SET(pp_read_iflistp, PIN_FLD_PRODUCT_OBJ, NULL, ebufp);
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Purchase product read purchase_end_t input flist", pp_read_iflistp);
		PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, pp_read_iflistp, &pp_read_oflistp, ebufp);
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Purchase product read purchase_end_t output flist", pp_read_oflistp);

		purchase_end_t = PIN_FLIST_FLD_GET(pp_read_oflistp, PIN_FLD_PURCHASE_END_T, 0, ebufp);
		service_pdp = PIN_FLIST_FLD_GET(pp_read_oflistp, PIN_FLD_SERVICE_OBJ, 0, ebufp);
		acc_pdp = PIN_FLIST_FLD_GET(pp_read_oflistp, PIN_FLD_ACCOUNT_OBJ, 0, ebufp);
		prod_pdp = PIN_FLIST_FLD_GET(pp_read_oflistp, PIN_FLD_PRODUCT_OBJ, 0, ebufp);
		bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);

		// Read product priority
		readproduct_inflistp = PIN_FLIST_CREATE(ebufp);
		PIN_FLIST_FLD_SET(readproduct_inflistp, PIN_FLD_POID, prod_pdp, ebufp );
		PIN_FLIST_FLD_SET(readproduct_inflistp, PIN_FLD_PRIORITY, 0, ebufp );

		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "update_for_topup read product input list", readproduct_inflistp);
		PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, readproduct_inflistp, &readproduct_outflistp, ebufp);
		PIN_FLIST_DESTROY_EX(&readproduct_inflistp, NULL);
		if (PIN_ERR_IS_ERR(ebufp))
		{
			PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_READ_FLDS", ebufp);
			PIN_ERR_CLEAR_ERR(ebufp);
			PIN_FLIST_DESTROY_EX(&readproduct_outflistp, NULL);	
			return;
		}
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "update_for_topup read product output flist", readproduct_outflistp);
		prod_priority = PIN_FLIST_FLD_GET(readproduct_outflistp, PIN_FLD_PRIORITY, 0, ebufp );
		prod_priority_double = pbo_decimal_to_double(prod_priority, ebufp);
		prod_priority_double = ((int)prod_priority_double) % 1000;
		PIN_FLIST_DESTROY_EX(&readproduct_outflistp, NULL);

		if(prod_priority_double >= BB_UNLIMITED_FUP_RANGE_START 
			&& prod_priority_double <= BB_UNLIMITED_FUP_RANGE_END)
		{
			fup_plan=1;
		}
		if(	!fup_plan ||
			((fup_plan && strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_grant") != 0) &&
			(fup_plan && strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_grant") != 0))
		    )
		{
			if(!is_add_mb) {
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,"Updating dates for topup.");
				timeeff = localtime(purchase_end_t);
				timeeff->tm_mon = timeeff->tm_mon - bill_when;
				charged_from_t = mktime (timeeff);

				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_FROM_T, &charged_from_t, ebufp );
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_START_T, &charged_from_t, ebufp );
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_TO_T, purchase_end_t, ebufp );
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_END_T, purchase_end_t, ebufp );

				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_FROM_T, &charged_from_t, ebufp );
				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_START_T, &charged_from_t, ebufp );
				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_TO_T, purchase_end_t, ebufp );
				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_END_T, purchase_end_t, ebufp );
			} else {
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,"Updating dates for Add MB.");
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_TO_T, purchase_end_t, ebufp );
				PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_END_T, purchase_end_t, ebufp );
				//align cycle fee start to charged from
				PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CHARGED_FROM_T, i_flistp, PIN_FLD_CYCLE_FEE_START_T, ebufp );

				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_TO_T, purchase_end_t, ebufp );
				PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_END_T, purchase_end_t, ebufp );
				PIN_FLIST_FLD_COPY(*r_flistpp, PIN_FLD_CHARGED_FROM_T, *r_flistpp, PIN_FLD_CYCLE_FEE_START_T, ebufp );
			}

		}
		else if(fup_plan && strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_grant") == 0)
		{
			PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,"Updating dates for Grant Product.");
			// Charged_to date must be set to 1 month from the expiry date of current plan.
			// New purcahse end date - bill when = expiry date of current plan
			// So we subtract bill_when and add 1 month to it.
			//timeeff = localtime(purchase_end_t);
			//timeeff->tm_mon = timeeff->tm_mon - bill_when + 1;
			//charged_to_t = mktime (timeeff);

			get_last_plan_valid_to_fup(ctxp, acc_pdp, service_pdp, &charged_to_t, ebufp);
			if (PIN_ERR_IS_ERR(ebufp))
			{
				PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling get_last_plan_valid_to_fup", ebufp);
				PIN_FLIST_DESTROY_EX(&readproduct_outflistp, NULL);	
				return;
			}
			//PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_FROM_T, &charged_from_t, ebufp );
			//PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_START_T, &charged_from_t, ebufp );
			PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_TO_T, &charged_to_t, ebufp );
			PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_END_T, &charged_to_t, ebufp );

			//PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_FROM_T, &charged_from_t, ebufp );
			//PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_START_T, &charged_from_t, ebufp );
			PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CHARGED_TO_T, &charged_to_t, ebufp );
			PIN_FLIST_FLD_SET(*r_flistpp, PIN_FLD_CYCLE_FEE_END_T, &charged_to_t, ebufp );
		}


	} else {
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG," Not a top-up flow. Doing nothing");
	}
	PIN_FLIST_DESTROY_EX(&pp_read_iflistp, NULL);
	PIN_FLIST_DESTROY_EX(&pp_read_oflistp, NULL);
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Leaving update_for_topup ");
    return;

}


/*********************************************************************************************************
*  calculating the correct end time for the fixed duration package
*  Any event added in the below finction, the same event should be added above at if condition
*********************************************************************************************************/

static void 
mso_fm_cycle_fee_evt_type(
pcm_context_t		*ctxp,
char			*event_type, 
time_t			*charged_from_t,
time_t			*charged_to_t,
int32			is_charged_t_bdom,
pin_errbuf_t		*ebufp)
{
	struct tm		*timeeff;

	if (PIN_ERR_IS_ERR(ebufp))
		return;

	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "mso_fm_cycle_fee_evt_type :");	

	timeeff = localtime(charged_from_t);

	if (event_type) 
	{
	     if(((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_sb_adn_fdp") == 0)
	               || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_sb_alc_fdp") == 0)
	               || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_sb_pkg_fdp") == 0) 
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual_fdp/mso_sb_norm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual_fdp/mso_sb_dc2") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual_fdp/mso_sb_dc3") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual_fdp/mso_sb_fib") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual_fdp/mso_sb_tod") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual_fdp/mso_grant") == 0))
	     || ((is_charged_t_bdom) && (
				   (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/huwr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/wlnd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/dcm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/nwifi") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/crsoho") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_amc/wlnd") == 0)
				
	       )))
	    {
		timeeff->tm_year = timeeff->tm_year + 1; 
	    }
	    else if (((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_sb_adn_fdp") == 0)
			    || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_sb_alc_fdp") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_sb_norm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_sb_dc2") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_sb_dc3") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_sb_fib") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_sb_tod") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_grant") == 0)
	                    || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_sb_pkg_fdp") == 0) )
			|| ((is_charged_t_bdom) &&  (
				    (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/huwr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/wlnd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/dcm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/nwifi") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/crsoho") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/wlnd") == 0)
                			/**** Pavan Bellala 21-09-2015 *******
        			        Added Additional IP Plan events
			                **************************************/
               		           || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental/ip")==0)
					/**** Pavan Bellala 14-10-2015 ****************
					Added Additional IP Plan events for all cycles
					***********************************************/
				|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/ip",
						strlen("/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/ip")) == 0)
				|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/ip",
						strlen("/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/ip")) == 0)
				|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/ip",
						strlen("/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/ip")) == 0)
				|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/ip",
						strlen("/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/ip")) == 0)
				|| (strncmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/ip",
						strlen("/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental/ip")) == 0)
	)))
	{
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Setting the charged_to_t to 1 month");
		timeeff->tm_mon = timeeff->tm_mon + 1; 
	}
	else if ((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_sb_adn_fdp") == 0)
	        || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_sb_alc_fdp") == 0)
	        || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_sb_pkg_fdp") == 0)
	        )
	{
		timeeff->tm_mon = timeeff->tm_mon + 2; 
	}
	else if (((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_sb_adn_fdp") == 0)
	 	            || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_sb_alc_fdp") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp/mso_sb_norm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp/mso_sb_dc2") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp/mso_sb_dc3") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp/mso_sb_fib") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp/mso_sb_tod") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly_fdp/mso_grant") == 0)
	                    || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_sb_pkg_fdp") == 0) )
		 || ((is_charged_t_bdom) && (
 				    (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/huwr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/wlnd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/dcm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/nwifi") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental/crsoho") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_amc/wlnd") == 0)
	        )))
	{
		timeeff->tm_mon = timeeff->tm_mon + 3; 
	}
	else if (((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_sb_adn_fdp") == 0)
	 	            || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_sb_alc_fdp") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp/mso_sb_norm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp/mso_sb_dc2") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp/mso_sb_dc3") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp/mso_sb_fib") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp/mso_sb_tod") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual_fdp/mso_grant") == 0)
	                    || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_sb_pkg_fdp") == 0) )
		|| ((is_charged_t_bdom) && (
				   (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/huwr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/wlnd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/dcm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/nwifi") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental/crsoho") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/cm") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/cr") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/nd") == 0)
				   || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_amc/wlnd") == 0)
	        )))
	{
		timeeff->tm_mon = timeeff->tm_mon + 6; 
	} else if (((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp/mso_sb_norm") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp/mso_sb_dc2") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp/mso_sb_dc3") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp/mso_sb_fib") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp/mso_sb_tod") == 0) 
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly_fdp/mso_grant") == 0)) 
		|| ((is_charged_t_bdom) && (
                 (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/cr") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/huwr") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/nd") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/wlnd") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/dcm") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/nwifi") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental/crsoho") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/cm") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/cr") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/nd") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_amc/wlnd") == 0)
		)))
	{
		timeeff->tm_mon = timeeff->tm_mon + 2;
	} else if (((strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp/mso_sb_norm") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp/mso_sb_dc2") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp/mso_sb_dc3") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp/mso_sb_fib") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp/mso_sb_tod") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly_fdp/mso_grant") == 0)) 
		|| ((is_charged_t_bdom) && (
                 (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/cr") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/huwr") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/nd") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/wlnd") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/dcm") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/nwifi") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental/crsoho") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/cm") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/cr") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/nd") == 0)
                 || (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_amc/wlnd") == 0)
                )))
        {
                timeeff->tm_mon = timeeff->tm_mon + 4;
        }

	// Set the timeeff to charged_to_t for hardware events with non BDOM charged day. Not AMC
	if(!is_charged_t_bdom && (strstr(event_type, "mso_hw") != NULL) && (strstr(event_type, AMC_EVENT) == NULL)) {
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Setting the charged_to_t to default");
	    timeeff = localtime(charged_to_t);
	} 
	}
	*charged_to_t = mktime (timeeff);

	return;
}


/*********************************************************************************************************
*  
*  
*********************************************************************************************************/

static int32 
fm_mso_modify_for_mcf(
	pcm_context_t		*ctxp,
	pin_flist_t		**i_flistp, 
	cm_op_info_t		*opstackp,
	pin_errbuf_t		*ebufp)
{
	pin_flist_t		*srch_billinfo_iflist = NULL;
	pin_flist_t		*srch_billinfo_oflist = NULL;
	pin_flist_t		*read_payinfo_iflist = NULL;
	pin_flist_t		*read_payinfo_oflist = NULL;
	pin_flist_t		*stack_flistp = NULL;
	pin_flist_t		*service_array = NULL;
	pin_flist_t		*bal_info = NULL;
	pin_flist_t		*results = NULL;
	pin_flist_t		*inv_info = NULL;
	pin_flist_t		*result_flist = NULL;
	pin_flist_t		*arg_flist = NULL;
	pin_flist_t		*update_billinfo_iflist = NULL;
	pin_flist_t		*update_billinfo_oflist = NULL;
	pin_flist_t		*catv_info = NULL;
	pin_flist_t		*svc_read_in_flistp = NULL;
	pin_flist_t		*svc_read_out_flistp = NULL;
	pin_flist_t		*bb_info = NULL;

	poid_t			*acnt_pdp = NULL;
	poid_t			*service_pdp = NULL;
	poid_t			*ar_billinfo_obj = NULL;

	int64			db = -1;
	int32			search_flags = 256;
	int32			activate_customer_failure = 1;
	int32			stack_opcode = 0;
	int32			flg_called_by_activation  = 0;
	int32			flg_called_by_billing     = 0;
	int32			flg_called_by_add_plan    = 0;
	int32			flg_called_by_cancel_plan = 0;
	int32			flg_called_by_change_plan = 0;
	int32			flg_called_by_suspend_srvc= 0;
	int32			flg_called_by_terminate_srvc=0;
	int32			flg_called_by_reactivate_srvc=0;
	int32			flg_called_by_bill_now=0;
	int32			flg_called_by_hold_svc=0;
	int32			flg_called_by_unhold_svc=0;
	int32                   flg_called_by_amc_advance = 0;
	pin_flist_t		*amc_iflistp = NULL;
	time_t           	amc_current_t = 0;
	time_t                  *amc_cycle_end_t = NULL;
	time_t			amc_default_time = 0;
	int32			prepaid_indicator = 0;
	int32			srch_flags = 256;
	int32			conn_type = -1;
	int32			partial_bill = 0;
	int32			*subscriber_type = NULL;

	char			log_buf[255];
	char			*prog_name = NULL;
	char			*service_pdp_type = NULL;
	char			billinfo_id[20];
	time_t			*next_bill_t = NULL;
	time_t			*future_bill_t = NULL;
	time_t			*actg_next_t = NULL;

	void			*vp = NULL;
	struct tm		*timeeff;
	int32			actg_cycle_dom = 1;
	int32			charged_day = 0;
	int32			bill_when = 0;
	time_t          *charged_from_t = NULL;
	time_t          charged_to_t = 0;
	int32			is_bb_service = 0;
	char                    *event_type = NULL;
	int32			has_change_plan = 0;
	int32 			status = 10100;
	char			*action = NULL;	

 	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf : Error");
		return 0;
	}
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf : Start");

	db = PIN_POID_GET_ID(PIN_FLIST_FLD_GET(*i_flistp, PIN_FLD_POID, 0, ebufp));
	charged_from_t = PIN_FLIST_FLD_GET(*i_flistp, PIN_FLD_CHARGED_FROM_T, 1, ebufp);
	event_type = PIN_FLIST_FLD_GET(*i_flistp, PIN_FLD_EVENT_TYPE, 1, ebufp); 

	svc_read_in_flistp = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_OFFERING_OBJ,svc_read_in_flistp,PIN_FLD_POID, ebufp);
	PIN_FLIST_FLD_SET(svc_read_in_flistp, PIN_FLD_SERVICE_OBJ, NULL, ebufp);
	PIN_FLIST_FLD_SET(svc_read_in_flistp, PIN_FLD_ACCOUNT_OBJ, NULL, ebufp);
	PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, svc_read_in_flistp, &svc_read_out_flistp, ebufp);
	acnt_pdp = PIN_FLIST_FLD_GET(svc_read_out_flistp, PIN_FLD_ACCOUNT_OBJ, 0, ebufp);
	service_pdp = PIN_FLIST_FLD_GET(svc_read_out_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp);
	service_pdp_type = (char*)PIN_POID_GET_TYPE(service_pdp);
	if(strcmp (service_pdp_type,"/service/telco/broadband")==0) {
	    is_bb_service = 1;
	}

	if (service_pdp_type && is_bb_service) {

		while(opstackp != NULL)
		{
			stack_opcode = opstackp->opcode;
			stack_flistp = opstackp->in_flistp;
			//if(stack_opcode == 10017)
			//{
			//		break;
			//}
			memset(log_buf, '\0', sizeof(log_buf));
			sprintf(log_buf, "Current opcode: %d, ", stack_opcode);
			PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, log_buf);
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "cm_op_info_t stack input flist is ", stack_flistp);
			action = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_ACTION, 1, ebufp);
			if(action &&(strstr(action, "UNHOLD_SERVICES")))
			{
				PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_ACTION, (int *)action, ebufp);	
			}
			prog_name = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_BILLINFO_OBJ, 1, ebufp);

			/* AMC POSTPAID CASE START */
                        if(event_type &&
                             (strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/cm/post") == 0
                              ||strcmp(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_amc/dcm/post") == 0))
                        {
                                PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "AMC ADVANCE SCENARIO");
                                flg_called_by_amc_advance = 1;
                                break;
                        }
                        /* AMC POSTPAID CASE END */


			if (stack_opcode == 102 && (prog_name && strcmp(prog_name, "pin_bill_accts")))
			{
				/*************************************************************************
				* if called by billing and opcode=102(PCM_OP_BILL_CYCLE_FORWARD)
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Billing input flist is ", stack_flistp);
				bal_info = PIN_FLIST_ELEM_GET(stack_flistp, PIN_FLD_BAL_INFO, 0, 1, ebufp);
				if (bal_info)
				{
					results = PIN_FLIST_ELEM_GET(bal_info, PIN_FLD_RESULTS, 0, 1, ebufp); 
					if (results)
					{
						//service_array=PIN_FLIST_ELEM_GET(results, PIN_FLD_SERVICES, 0, 1, ebufp);
						//if (service_array)
						//{
							//commented becuase it picks wrong service poid in case of two services
							//service_pdp=PIN_FLIST_FLD_GET(results, PIN_FLD_SERVICE_OBJ, 1, ebufp);
							acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
							flg_called_by_billing = 1;
							break;
						//}
					}
				}
			}
			else if(stack_opcode == PCM_OP_CUST_SET_PRODUCT_STATUS)
			{
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, " Set product status flist called . Capture the service and account object to be used if this is activation flow",stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp,PIN_FLD_SERVICE_OBJ,0, ebufp);
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp,PIN_FLD_POID,0,ebufp);
				// Do not set the flag or break. Go through the loop to determine if this is a part of activation call or not.
				// acct and svc poids will be overwritten anyways in other checks.
			}
			else if(stack_opcode == MSO_OP_PROV_BB_PROCESS_RESPONSE ||
				( stack_opcode == MSO_OP_CUST_ACTIVATE_BB_SERVICE && event_type && 
				( strstr(event_type, "/event/billing/product/fee/cycle/cycle_forward_monthly/mso_hw_rental") ||
				strstr( event_type, "/event/billing/product/fee/cycle/cycle_forward_bimonthly/mso_hw_rental" ) ||
				strstr( event_type, "/event/billing/product/fee/cycle/cycle_forward_quarterly/mso_hw_rental" ) ||
				strstr( event_type, "/event/billing/product/fee/cycle/cycle_forward_quadmonthly/mso_hw_rental" ) ||
				strstr( event_type, "/event/billing/product/fee/cycle/cycle_forward_semiannual/mso_hw_rental" ) ||
				strstr( event_type, "/event/billing/product/fee/cycle/cycle_forward_annual/mso_hw_rental" ))))
								// Will be called only upon activation 
			{
				/*************************************************************************
				* if called by activation and opcode=11205()
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Activation input flist is ", stack_flistp);
					flg_called_by_activation = 1;
					break;
			}
			else if ( stack_opcode == 11007)
			{
				/*************************************************************************
				* if called by add plan
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "add plan input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				subscriber_type = (int32*)PIN_FLIST_FLD_GET(stack_flistp, MSO_FLD_SUBSCRIBER_TYPE, 1, ebufp );
				if (service_pdp)
				{
					flg_called_by_add_plan = 1;
					break;
				}
			}
			else if ( stack_opcode == 11006)
			{
				/*************************************************************************
				* if called by cancel plan
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "cancel plan input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_cancel_plan = 1;
					break;
				}
			}
			else if ( stack_opcode == 11005)
			{
				/*************************************************************************
				* if called by change plan
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "change plan input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_cancel_plan = 1;
					break;
				}
			}
			else if ( stack_opcode == 11008)
			{
				/*************************************************************************
				* if called by suspend service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "suspend service input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_suspend_srvc = 1;
					break;
				}
			}
			else if ( stack_opcode == 11009)
			{
				/*************************************************************************
				* if called by terminate service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "terminate service input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_terminate_srvc = 1;
					break;
				}
			}
			else if ( stack_opcode == 11010)
			{
				/*************************************************************************
				* if called by reactivate service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "reactivate service input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_reactivate_srvc = 1;
					break;
				}
			}
			else if ( stack_opcode == 13200) // MSO_OP_BILL_MAKE_BILL_NOW
			{
				/*************************************************************************
				* if called by reactivate service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "mso_op_bill_make_now input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_ACCOUNT_OBJ, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_bill_now = 1;
					break;
				}
			}
			else if(stack_opcode == MSO_OP_CUST_HOLD_SERVICE) {
				/*************************************************************************
				* if called by hold service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "MSO_OP_CUST_HOLD_SERVICE flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_hold_svc = 1;
					break;
				}
			}
			else if(stack_opcode == MSO_OP_CUST_UNHOLD_SERVICE) {
				/*************************************************************************
				* if called by hold service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "MSO_OP_CUST_UNHOLD_SERVICE flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_unhold_svc = 1;
					break;
				}
			}
			opstackp = opstackp->next;
		}
		strcpy(billinfo_id, "BB");
	}else { // CaTV
		while(opstackp != NULL)
		{
			stack_opcode = opstackp->opcode;
			stack_flistp = opstackp->in_flistp;
			//if(stack_opcode == 10017)
			//{
			//		break;
			//}
			memset(log_buf, '\0', sizeof(log_buf));
			sprintf(log_buf, "Current opcode: %d, ", stack_opcode);
			PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, log_buf);
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "cm_op_info_t stack input flist is ", stack_flistp);

			prog_name = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_BILLINFO_OBJ, 1, ebufp);

			if (stack_opcode == 102 && (prog_name && strcmp(prog_name, "pin_bill_accts")))
			{
				/*************************************************************************
				* if called by billing and opcode=102(PCM_OP_BILL_CYCLE_FORWARD)
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Billing input flist is ", stack_flistp);
				bal_info = PIN_FLIST_ELEM_GET(stack_flistp, PIN_FLD_BAL_INFO, 0, 1, ebufp);
				if (bal_info)
				{
					results = PIN_FLIST_ELEM_GET(bal_info, PIN_FLD_RESULTS, 0, 1, ebufp); 
					if (results)
					{
						//service_array=PIN_FLIST_ELEM_GET(results, PIN_FLD_SERVICES, 0, 1, ebufp);
						//if (service_array)
						//{
							service_pdp=PIN_FLIST_FLD_GET(results, PIN_FLD_SERVICE_OBJ, 1, ebufp);
							acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
							flg_called_by_billing = 1;
							break;
						//}
					}
				}
			}
			else if(stack_opcode == 11002 )
			{
				/*************************************************************************
				* if called by activation and opcode=11002()
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Activation input flist is ", stack_flistp);
				service_array = PIN_FLIST_ELEM_GET(stack_flistp, PIN_FLD_SERVICES, 0, 1, ebufp );
				if (service_array)
				{
					service_pdp=PIN_FLIST_FLD_GET(service_array, PIN_FLD_SERVICE_OBJ, 0, ebufp);
					acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_ACCOUNT_OBJ, 0, ebufp); 
					catv_info = PIN_FLIST_SUBSTR_GET(service_array, MSO_FLD_CATV_INFO, 1, ebufp);
					vp = PIN_FLIST_FLD_GET(catv_info, PIN_FLD_CONN_TYPE, 1, ebufp);
					if (vp && *(int32*)vp == 1)
					{
						conn_type = 1;
					}
					flg_called_by_activation = 1;
					break;
				}
				
			}
			else if ( stack_opcode == 11007)
			{
				/*************************************************************************
				* if called by add plan
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "add plan input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				subscriber_type = (int32*)PIN_FLIST_FLD_GET(stack_flistp, MSO_FLD_SUBSCRIBER_TYPE, 1, ebufp );
				if (service_pdp)
				{
					flg_called_by_add_plan = 1;
					break;
				}
			}
			else if ( stack_opcode == 11006)
			{
				/*************************************************************************
				* if called by cancel plan
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "cancel plan input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_cancel_plan = 1;
					break;
				}
			}
			else if ( stack_opcode == 11005)
			{
				/*************************************************************************
				* if called by change plan
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "change plan input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_cancel_plan = 1;
					break;
				}
			}
			else if ( stack_opcode == 11008)
			{
				/*************************************************************************
				* if called by suspend service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "suspend service input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_suspend_srvc = 1;
					break;
				}
			}
			else if ( stack_opcode == 11009)
			{
				/*************************************************************************
				* if called by terminate service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "terminate service input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_terminate_srvc = 1;
					break;
				}
			}
			else if ( stack_opcode == 11010)
			{
				/*************************************************************************
				* if called by reactivate service
				*************************************************************************/
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "reactivate service input flist is ", stack_flistp);
				service_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp );
				acnt_pdp = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_POID, 0, ebufp);
				if (service_pdp)
				{
					flg_called_by_reactivate_srvc = 1;
					break;
				}
			}			
			opstackp = opstackp->next;
		}
		strcpy(billinfo_id, "CATV");
	}


	
	if (!service_pdp || !acnt_pdp)
	{
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Unable to find Account/Service");
		return 0;
	}

	//Search BILLINFO Start
	/*service_pdp_type = (char*)PIN_POID_GET_TYPE(service_pdp);
	if (service_pdp_type && strcmp (service_pdp_type,"/service/catv")==0)
	{
		strcpy(billinfo_id, "CATV");
	}
	else
	{
		strcpy(billinfo_id, "BB");
	}*/


	db = PIN_POID_GET_DB(acnt_pdp);
	srch_billinfo_iflist = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_PUT(srch_billinfo_iflist, PIN_FLD_POID, PIN_POID_CREATE(db, "/search", -1, ebufp), ebufp);
	PIN_FLIST_FLD_SET(srch_billinfo_iflist, PIN_FLD_FLAGS, &srch_flags, ebufp);
	PIN_FLIST_FLD_SET(srch_billinfo_iflist, PIN_FLD_TEMPLATE, "select X from /billinfo  where F1.id = V1 and F2 = V2 and F3 = V3", ebufp);
	//PIN_FLIST_FLD_SET(srch_billinfo_iflist, PIN_FLD_TEMPLATE, "select X from /billinfo  where F1.id = V1 and F2 = V2 ", ebufp);
	arg_flist = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_ARGS, 1, ebufp);
	PIN_FLIST_FLD_SET(arg_flist, PIN_FLD_ACCOUNT_OBJ, acnt_pdp, ebufp);

	arg_flist = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_ARGS, 2, ebufp);
	PIN_FLIST_FLD_SET(arg_flist, PIN_FLD_BILLINFO_ID, billinfo_id, ebufp);
	
	 //Added to pick only active billinfo's
        arg_flist = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_ARGS, 3, ebufp);
        PIN_FLIST_FLD_SET(arg_flist, PIN_FLD_STATUS,&status, ebufp);


	result_flist = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_RESULTS, 0, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_NEXT_BILL_T, NULL, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_ACTG_CYCLE_DOM, NULL, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_FUTURE_BILL_T, NULL, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_ACTG_NEXT_T, NULL, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_PAYINFO_OBJ, NULL, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_PAY_TYPE, NULL, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_BILLING_STATE, NULL, ebufp);
	PIN_FLIST_FLD_SET(result_flist, PIN_FLD_AR_BILLINFO_OBJ, NULL, ebufp);

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf search billinfo input list", srch_billinfo_iflist);
	PCM_OP(ctxp, PCM_OP_SEARCH, 0, srch_billinfo_iflist, &srch_billinfo_oflist, ebufp);
	PIN_FLIST_DESTROY_EX(&srch_billinfo_iflist, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_SEARCH", ebufp);
		PIN_FLIST_DESTROY_EX(&srch_billinfo_oflist, NULL);
		return 0;
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf search billinfo output flist", srch_billinfo_oflist);
	result_flist = PIN_FLIST_ELEM_GET(srch_billinfo_oflist, PIN_FLD_RESULTS, 0, 1, ebufp);

	if (result_flist)
	{	/*********************************************************************************
		* If the thccount is non-paying child then use the /payinfo of  parent
		*********************************************************************************/
		partial_bill = *((int32*)PIN_FLIST_FLD_GET(result_flist, PIN_FLD_BILLING_STATE, 0, ebufp));
		actg_next_t = PIN_FLIST_FLD_GET(result_flist, PIN_FLD_ACTG_NEXT_T, 1, ebufp);
		next_bill_t = PIN_FLIST_FLD_GET(result_flist, PIN_FLD_NEXT_BILL_T, 1, ebufp);
		
		if (*(int32*)PIN_FLIST_FLD_GET(result_flist, PIN_FLD_PAY_TYPE, 0, ebufp) == 10007 )
		{
			ar_billinfo_obj = PIN_POID_COPY((poid_t*)PIN_FLIST_FLD_GET(result_flist, PIN_FLD_AR_BILLINFO_OBJ, 0, ebufp) , ebufp);
			PIN_FLIST_DESTROY_EX(&srch_billinfo_oflist, NULL);
			PIN_ERR_LOG_POID(PIN_ERR_LEVEL_DEBUG, "ar_billinfo_obj", ar_billinfo_obj);

			srch_billinfo_iflist = PIN_FLIST_CREATE(ebufp);
			PIN_FLIST_FLD_PUT(srch_billinfo_iflist, PIN_FLD_POID, PIN_POID_CREATE(db, "/search", -1, ebufp), ebufp);
			PIN_FLIST_FLD_SET(srch_billinfo_iflist, PIN_FLD_FLAGS, &srch_flags, ebufp);
			PIN_FLIST_FLD_SET(srch_billinfo_iflist, PIN_FLD_TEMPLATE, "select X from /billinfo  where F1.id = V1 ", ebufp);

			arg_flist = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_ARGS, 1, ebufp);
			PIN_FLIST_FLD_SET(arg_flist, PIN_FLD_POID, ar_billinfo_obj, ebufp);

			result_flist = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_RESULTS, 0, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_NEXT_BILL_T, NULL, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_ACTG_CYCLE_DOM, NULL, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_FUTURE_BILL_T, NULL, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_ACTG_NEXT_T, NULL, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_PAYINFO_OBJ, NULL, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_PAY_TYPE, NULL, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_BILLING_STATE, NULL, ebufp);
			PIN_FLIST_FLD_SET(result_flist, PIN_FLD_AR_BILLINFO_OBJ, NULL, ebufp);


			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "parent: fm_mso_modify_for_mcf search billinfo input list", srch_billinfo_iflist);
			PCM_OP(ctxp, PCM_OP_SEARCH, 0, srch_billinfo_iflist, &srch_billinfo_oflist, ebufp);
			PIN_FLIST_DESTROY_EX(&srch_billinfo_iflist, NULL);
			if (PIN_ERR_IS_ERR(ebufp))
			{
				PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_SEARCH", ebufp);
				PIN_FLIST_DESTROY_EX(&srch_billinfo_oflist, NULL);
				return 0;
			}
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "parent:fm_mso_modify_for_mcf search billinfo output flist", srch_billinfo_oflist);
			result_flist = PIN_FLIST_ELEM_GET(srch_billinfo_oflist, PIN_FLD_RESULTS, 0, 1, ebufp);
		}
	}

 	if (result_flist)
	{
		//Read PAYINFO Start
		read_payinfo_iflist = PIN_FLIST_CREATE(ebufp);
		PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_PAYINFO_OBJ, read_payinfo_iflist, PIN_FLD_POID, ebufp);
		PIN_FLIST_ELEM_SET(read_payinfo_iflist, NULL, PIN_FLD_INV_INFO, 0, ebufp );

		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf read payinfo input list", read_payinfo_iflist);
		PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, read_payinfo_iflist, &read_payinfo_oflist, ebufp);
		PIN_FLIST_DESTROY_EX(&read_payinfo_iflist, NULL);
		if (PIN_ERR_IS_ERR(ebufp))
		{
			PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_READ_FLDS", ebufp);
			PIN_FLIST_DESTROY_EX(&read_payinfo_oflist, NULL);
			return 0;
		}
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf read payinfo output flist", read_payinfo_oflist);
		if (read_payinfo_oflist)
		{
			inv_info = PIN_FLIST_ELEM_GET(read_payinfo_oflist, PIN_FLD_INV_INFO, 0, 1, ebufp);
			prepaid_indicator = *(int32 *)PIN_FLIST_FLD_GET(inv_info, PIN_FLD_INDICATOR, 0, ebufp);
		}
		PIN_FLIST_DESTROY_EX(&read_payinfo_oflist, NULL);
		//Read PAYINFO End

		if ((prepaid_indicator == PREPAID) || (!is_bb_service && prepaid_indicator == CATV_PREPAID))
		{
			PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "prepaid_indicator == PREPAID");
			if (flg_called_by_activation && conn_type ==1 )	//Addl connection
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_activation");
			  	if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
				{

					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T, *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T, *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );

				}
				else
				{

					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T, *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T, *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );				
				}
			}
			else if (flg_called_by_billing)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_billing");
				PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
				PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );

			}
			else if (flg_called_by_cancel_plan)
			{
				if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
                   {
                           /*PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_cancel_plan");
                           PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                           //PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                           PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                           PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );*/

                           PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_cancel_plan");
                           PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                           PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                           PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
                   }
                   else
                   {
                           /*PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_cancel_plan");
                           PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                           PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                           PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );*/

                           PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_cancel_plan");
                           PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                           //PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                           PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                           PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp ); 
                  }

			}
			else if (flg_called_by_add_plan)
			{
				if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
                {
                        /*PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_add_plan");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );*/

                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_add_plan1");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
                }
                else
                {
                        /*PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_add_plan1");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );*/

                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_add_plan");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
                }
			}
			else if (flg_called_by_change_plan)
			{
				if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
                {
                        /*PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_change_plan");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );*/

                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_change_plan");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
                }
                else
                {
                        /*PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_change_plan");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );*/

                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_change_plan");
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                        PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                        PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
                }
			} 
			else if (flg_called_by_hold_svc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_hold_svc. Do nothing.");
			}
			else if (flg_called_by_unhold_svc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_unhold_svc. Do nothing");
			}
			else if (flg_called_by_suspend_srvc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_suspend_srvc");
				//PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
				//PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
				//PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
			}
			else if (flg_called_by_terminate_srvc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_terminate_srvc");
				PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
				PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
				               //      PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                                if(is_bb_service)
                               {
                                       PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                               }

			}
			else if (flg_called_by_reactivate_srvc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_reactivate_srvc");
				PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
			}
		}

		//	Broadband changes
		if (prepaid_indicator == ADVANCE && is_bb_service)
		{	
			timeeff = localtime(charged_from_t);
			actg_cycle_dom = *(int32 *)PIN_FLIST_FLD_GET(result_flist,PIN_FLD_ACTG_CYCLE_DOM,0, ebufp);
			charged_day = timeeff->tm_mday;

			PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "prepaid_indicator == ADVANCE");
			if (flg_called_by_activation)	//Addl connection
			{						
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_activation");
				if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
				{
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T, *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T, *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
				}
				else
				{				
					// if current date is in middle of month, use next_bill_t. Otherwise, if it is DOM, then determine the 
					// BILL_WHEN and add payterm number of months to charge_from_t.					

					if(charged_day != actg_cycle_dom) {
						PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
						PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );				
					} else {
						bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);
						timeeff->tm_mon = timeeff->tm_mon + bill_when;
						charged_to_t = mktime (timeeff);
						PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CHARGED_TO_T ,&charged_to_t, ebufp );
						PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_END_T ,&charged_to_t, ebufp );
					}
				}
			}
			else if (flg_called_by_billing)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_billing");
				if(charged_day != actg_cycle_dom) {
				    PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );				
				} else {
					bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);
					timeeff->tm_mon = timeeff->tm_mon + bill_when;
					charged_to_t = mktime (timeeff);
					PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CHARGED_TO_T ,&charged_to_t, ebufp );
					PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_END_T ,&charged_to_t, ebufp );

				}
				
			}
			else if (flg_called_by_cancel_plan)
			{
				if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_cancel_plan");
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
					PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
				}
				else
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_cancel_plan");
					if(charged_day != actg_cycle_dom) {
						PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
						PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
						PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );				
					} else {
						PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Reading Bill When from Service");
                        bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);
                        timeeff->tm_mon = timeeff->tm_mon + bill_when;
                        charged_to_t = mktime (timeeff);
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CHARGED_TO_T ,&charged_to_t, ebufp );
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_END_T ,&charged_to_t, ebufp );
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_START_T ,&charged_to_t,  ebufp );
					}
				}
					

				
			}
			else if (flg_called_by_add_plan)
			{
				if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_add_plan1");
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
					PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
				}
				else
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_add_plan");
					if(charged_day != actg_cycle_dom) {
						PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
						PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
						PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );			
					} else {
						PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Reading Bill When from Service");
                        bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);
                        timeeff->tm_mon = timeeff->tm_mon + bill_when;
                        charged_to_t = mktime (timeeff);
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CHARGED_TO_T ,&charged_to_t, ebufp );
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_END_T ,&charged_to_t, ebufp );
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_START_T ,&charged_to_t,  ebufp );					
					}
				}
			}
			else if (flg_called_by_change_plan)
			{
				if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_change_plan");
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
					PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
					PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
				}
				else
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_change_plan");
					if(charged_day != actg_cycle_dom) { 
						PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
						PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
						PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
					}else {
						PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Reading Bill When from Service");
                        bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);
                        timeeff->tm_mon = timeeff->tm_mon + bill_when;
                        charged_to_t = mktime (timeeff);
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CHARGED_TO_T ,&charged_to_t, ebufp );
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_END_T ,&charged_to_t, ebufp );
                        PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_START_T ,&charged_to_t,  ebufp );
					}
					
				}
			} 
			else if (flg_called_by_suspend_srvc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_suspend_srvc");
				//PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
				//PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
				//PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
			}
			else if (flg_called_by_terminate_srvc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_terminate_srvc");
				/*
				PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
				PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
				PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_END_T,   *i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
				*/
			}
			else if (flg_called_by_reactivate_srvc)
			{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "called_by_reactivate_srvc");
				//PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   *i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
			}
			/* AMC CHANGES START */
                        else if(flg_called_by_amc_advance)
                        {
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "flg_called_by_amc_advance");

				while(opstackp != NULL)
				{
					stack_opcode = opstackp->opcode;
					if (stack_opcode == 11005)
						has_change_plan = 1;
					opstackp = opstackp->next;
				}

				if(stack_opcode == MSO_OP_CUST_HOLD_SERVICE || stack_opcode == MSO_OP_CUST_TERMINATE_SERVICE)
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "AMC HOLD/TERMINATE");
					return 1;
				}

				amc_iflistp = PIN_FLIST_CREATE(ebufp);
				PIN_FLIST_FLD_SET(amc_iflistp, PIN_FLD_POID, acnt_pdp, ebufp);
				/* read subscription product cycle end date */
				fm_mso_cust_bb_hw_amc_get_cycle_details(ctxp, amc_iflistp, ebufp);

			        if (PIN_ERR_IS_ERR(ebufp))
        			{
            				PIN_ERR_CLEAR_ERR(ebufp);
					amc_default_time = pin_virtual_time(NULL);
					PIN_FLIST_FLD_SET(amc_iflistp, PIN_FLD_CYCLE_END_T, &amc_default_time, ebufp);

        			}

				amc_cycle_end_t = PIN_FLIST_FLD_GET(amc_iflistp, PIN_FLD_CYCLE_END_T, 0, ebufp);
				amc_current_t = pin_virtual_time(NULL);

                                PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "flg_called_by_amc_advance setting bill_when");
                                PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Reading Bill When from Service");
                                bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);
			
				if(amc_cycle_end_t && amc_current_t >= *amc_cycle_end_t)
				{
					timeeff = localtime(amc_cycle_end_t);
					timeeff->tm_mon = timeeff->tm_mon + bill_when;
					charged_to_t = mktime (timeeff);
				}
				else
				{
					timeeff = localtime(amc_cycle_end_t);
					charged_to_t = mktime (timeeff);
				}
                                PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CHARGED_TO_T ,&charged_to_t, ebufp );
                                PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_END_T ,&charged_to_t, ebufp );
				PIN_FLIST_DESTROY_EX(&amc_iflistp, NULL);
				if (stack_opcode == 11005 || (has_change_plan == 1 && stack_opcode == MSO_OP_CUST_CALC_PRICE))
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "flg_called_by_amc_advance CHANGE PLAN");
                                	if (partial_bill == 1 && (*actg_next_t == *next_bill_t))
                                	{
                                        	PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   
									*i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                                        	PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_FUTURE_BILL_T,   
									*i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                                        	PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   
									*i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
                                	}
                                	else
                                	{
                                        	if(charged_day != actg_cycle_dom) 
						{
                                                	PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   
									*i_flistp, PIN_FLD_CHARGED_TO_T , ebufp );
                                                	PIN_FLIST_FLD_COPY(result_flist, PIN_FLD_NEXT_BILL_T,   
									*i_flistp, PIN_FLD_CYCLE_FEE_END_T , ebufp );
                                                	PIN_FLIST_FLD_COPY(*i_flistp, PIN_FLD_CHARGED_FROM_T,   
									*i_flistp, PIN_FLD_CYCLE_FEE_START_T , ebufp );
                                        	}
						else 
						{
                                                	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Reading Bill When from Service");
                        				bill_when = get_bill_when_from_service(ctxp, service_pdp, ebufp);
                        				timeeff = localtime(charged_from_t);
							timeeff->tm_mon = timeeff->tm_mon + bill_when;
                        				charged_to_t = mktime (timeeff);
                        				PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CHARGED_TO_T ,&charged_to_t, ebufp );
                        				PIN_FLIST_FLD_SET(*i_flistp, PIN_FLD_CYCLE_FEE_END_T ,&charged_to_t, ebufp );
                                        	}
                                	}
				}


                        } /* AMC CHANGES END */

		}
	}
	else
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Search returning NULL", ebufp);
		PIN_FLIST_DESTROY_EX(&srch_billinfo_oflist, NULL);
		return 0;
	}

	PIN_FLIST_DESTROY_EX(&srch_billinfo_oflist, NULL);

	return 1;
}



void read_prod_details(pcm_context_t		*ctxp,
		pin_flist_t		*i_flistp,
		pin_flist_t		**prod_flistp,
		pin_errbuf_t		*ebufp)
{
	pin_flist_t	*read_in_flistp = NULL;
	pin_flist_t	*read_out_flistp = NULL;
	poid_t		*prod_pdp = NULL;

	prod_pdp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_PRODUCT_OBJ, 0, ebufp);

	read_in_flistp = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_PRODUCT_OBJ, read_in_flistp, PIN_FLD_POID, ebufp);
	PIN_FLIST_FLD_SET(read_in_flistp, PIN_FLD_PRIORITY, NULL, ebufp);
	PIN_FLIST_FLD_SET(read_in_flistp, PIN_FLD_PERMITTED, NULL, ebufp);

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "read_prod_details read product input list", read_in_flistp);
	PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, read_in_flistp, &read_out_flistp, ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "read_prod_details read product output list", read_out_flistp);

	*prod_flistp = PIN_FLIST_COPY(read_out_flistp,ebufp);
	return;
}

void fm_mso_update_service_fup_status(
		cm_nap_connection_t     *connp,
		pcm_context_t		*ctxp,
		pin_flist_t		*i_flistp,
		pin_flist_t		*prod_flistp,
		char			*event_type,
		cm_op_info_t            *opstackp,
		pin_flist_t		*r_flistp,
		pin_errbuf_t		*ebufp) {

	poid_t	*product_pdp = NULL;
	poid_t		*acnt_pdp = NULL;
	char	*permitted=NULL;
	char	*broadband = "/service/telco/broadband";
	poid_t		*service_obj = NULL; 
	int32		flag = 0;
	pin_flist_t	*svc_upd_in_flistp = NULL;
	pin_flist_t	*svc_upd_out_flistp = NULL;
	pin_flist_t	*read_in_flistp = NULL;
	pin_flist_t	*read_out_flistp = NULL;
	pin_flist_t	*bb_info_flistp = NULL;
	char	msg[250];
	double	prod_priority = 0;
	int32	fup_status = BEF_FUP;
	int32 prepaid_fup_start = (BB_PREPAID_START + BB_UNLIMITED_FUP_RANGE_START);
	int32 prepaid_fup_end = (BB_PREPAID_START + BB_UNLIMITED_FUP_RANGE_END);
	int32 postpaid_fup_start = (BB_POSTPAID_START + BB_UNLIMITED_FUP_RANGE_START);
	int32 postpaid_fup_end = (BB_POSTPAID_START + BB_UNLIMITED_FUP_RANGE_END);
	int32 postpaid_lim_start = (BB_POSTPAID_START + BB_LIMITED_RANGE_START);
	int32 postpaid_lim_end = (BB_POSTPAID_START + BB_LIMITED_RANGE_END);
	int32 postpaid_unlim_start = (BB_POSTPAID_START + BB_UNLIMITED_NO_FUP_RANGE_START);
        int32 postpaid_unlim_end = (BB_POSTPAID_START + BB_UNLIMITED_NO_FUP_RANGE_END);
	char		*action = NULL;	
	pin_cookie_t    c_cookie = NULL;	
	int32           c_elem_id = 0;
	pin_flist_t	*cycle_fees_flistp = NULL;	
	time_t		*chrg_from = NULL;
	time_t		chrg_to;
	int32		*count = NULL;
	int32		*indictor = NULL;
	time_t		*chrg_frm = NULL;	
	int		an_local = 0;
	struct tm       *timeeff;	
	
	int32		*count_inp = NULL;
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Reading PERMITTED");
	permitted = PIN_FLIST_FLD_GET(prod_flistp, PIN_FLD_PERMITTED, 0, ebufp);

	if(strcmp(event_type,"/event/billing/product/fee/cycle/cycle_forward_monthly/mso_grant") != 0  &&
	   strcmp(event_type,"/event/billing/product/fee/cycle/cycle_forward_monthly_fdp/mso_grant") != 0
	  ) 
	{
	    return;
	}

	if ((permitted != NULL) && strcmp(permitted, broadband) == 0)
	{	

                product_pdp = PIN_FLIST_FLD_GET(i_flistp,PIN_FLD_PRODUCT_OBJ,1,ebufp);
	
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Reading PRIORITY");
		prod_priority = pbo_decimal_to_double( PIN_FLIST_FLD_GET(prod_flistp, PIN_FLD_PRIORITY, 0, ebufp),ebufp);		
		prod_priority = ((int)prod_priority%1000);

		read_in_flistp = PIN_FLIST_CREATE(ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_OFFERING_OBJ, read_in_flistp, PIN_FLD_POID, ebufp);
		PIN_FLIST_FLD_SET(read_in_flistp, PIN_FLD_SERVICE_OBJ, NULL, ebufp);
		PCM_OP(ctxp, PCM_OP_READ_OBJ, 0, read_in_flistp, &read_out_flistp, ebufp);
		service_obj = PIN_FLIST_FLD_GET(read_out_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp);
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_update_service_fup_status readobj purchased_product", read_out_flistp);
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Comparing PRIORITY");
		action = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_ACTION, 1, ebufp);
		if(action != NULL)
		{
                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, action);
                        svc_upd_in_flistp = PIN_FLIST_CREATE(ebufp);
                        PIN_FLIST_FLD_SET(svc_upd_in_flistp, PIN_FLD_POID, service_obj, ebufp);
                        bb_info_flistp = PIN_FLIST_ELEM_ADD(svc_upd_in_flistp, MSO_FLD_BB_INFO, 0, ebufp);
                        PIN_FLIST_FLD_SET(bb_info_flistp, PIN_FLD_INDICATOR, (int *)NULL, ebufp);
                        PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_update_service_fup_status readflds service input list", svc_upd_in_flistp);
                        PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, svc_upd_in_flistp, &svc_upd_out_flistp, ebufp);
                        PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_update_service_fup_status readflds service output list", svc_upd_out_flistp);
                        PIN_FLIST_DESTROY_EX(&svc_upd_in_flistp, NULL);
                        if(PIN_ERR_IS_ERR(ebufp))
                        {
                                PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error calling service readflds ", ebufp);
                        }
			bb_info_flistp = PIN_FLIST_ELEM_GET(svc_upd_out_flistp, MSO_FLD_BB_INFO, PIN_ELEMID_ANY, 1, ebufp);
                        indictor = PIN_FLIST_FLD_GET(bb_info_flistp, PIN_FLD_INDICATOR, 1, ebufp);
			
                        if(indictor && *indictor == 1)
                        {
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "check111");
				chrg_frm = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_FROM_T, 1, ebufp);
				c_cookie = NULL;
			   while ((cycle_fees_flistp = PIN_FLIST_ELEM_GET_NEXT(read_out_flistp, PIN_FLD_CYCLE_FEES,
                                        &c_elem_id, 1, &c_cookie, ebufp)) != NULL)
                       	   {
				
				count = PIN_FLIST_FLD_GET(cycle_fees_flistp, PIN_FLD_COUNT, 1, ebufp);	
				count_inp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_COUNT, 1, ebufp);
				if(count && count_inp && *count == *count_inp)
				{
				   
				   chrg_from = PIN_FLIST_FLD_GET(cycle_fees_flistp, PIN_FLD_CHARGED_FROM_T, 0, ebufp);
				}
				
				if(chrg_from)
				{
					timeeff = localtime(chrg_from);	
					
					timeeff->tm_mon = timeeff->tm_mon + 1;
					
					timeeff->tm_mday = 1;
					
					chrg_to = mktime (timeeff);
					if(chrg_frm && (chrg_to > *chrg_frm))
					{
						PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "SHOULD NOT RENEW THIS PRODUCT");
						action = NULL;	
					}
				}
			    }
			}
			  PIN_FLIST_DESTROY_EX(&svc_upd_out_flistp, NULL);
		   }
		 	
		if((prod_priority >= prepaid_fup_start && prod_priority <= prepaid_fup_end) ||
			(prod_priority >= postpaid_fup_start && prod_priority <= postpaid_fup_end)) {
			svc_upd_in_flistp = PIN_FLIST_CREATE(ebufp);
			PIN_FLIST_FLD_SET(svc_upd_in_flistp, PIN_FLD_POID, service_obj, ebufp);
			bb_info_flistp = PIN_FLIST_ELEM_ADD(svc_upd_in_flistp, MSO_FLD_BB_INFO, 0, ebufp);
			PIN_FLIST_FLD_SET(bb_info_flistp, MSO_FLD_FUP_STATUS, &fup_status, ebufp);
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_update_service_fup_status update service input list", svc_upd_in_flistp);
			PCM_OP(ctxp, PCM_OP_WRITE_FLDS, 32, svc_upd_in_flistp, &svc_upd_out_flistp, ebufp);
			PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_update_service_fup_status update service output list", svc_upd_out_flistp);
			PIN_FLIST_DESTROY_EX(&svc_upd_in_flistp, NULL);
			PIN_FLIST_DESTROY_EX(&svc_upd_out_flistp, NULL);
		}

	    sprintf(msg, "priority is %f", prod_priority);
	    PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, msg);
	    sprintf(msg, "Prepaid FUP range  is [%d-%d]", prepaid_fup_start, prepaid_fup_end);
	    PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, msg);
	    sprintf(msg, "Postpaid FUP range  is [%d-%d]", postpaid_fup_start, postpaid_fup_end);
	    PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, msg);
	    sprintf(msg, "Postpaid limited range  is [%d-%d]", postpaid_lim_start, postpaid_lim_end);
	    PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, msg);
	    sprintf(msg, "Postpaid unlimited range  is [%d-%d]", postpaid_unlim_start, postpaid_unlim_end);
            PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, msg);
		

	    if((prod_priority >= prepaid_fup_start && prod_priority <= prepaid_fup_end) ||
               (prod_priority >= postpaid_fup_start && prod_priority <= postpaid_fup_end) ||
	       (prod_priority >= postpaid_unlim_start && prod_priority <= postpaid_unlim_end)||
		(prod_priority >= postpaid_lim_start && prod_priority <= postpaid_lim_end)) {

	    sprintf(msg, "In the range for renewal quota");
	    PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, msg);
	
		acnt_pdp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_POID, 0, ebufp);
	    if((prod_priority >= prepaid_fup_start && prod_priority <= prepaid_fup_end) ||
               (prod_priority >= postpaid_fup_start && prod_priority <= postpaid_fup_end)||
	       (prod_priority >= postpaid_unlim_start && prod_priority <= postpaid_unlim_end))
            {
		flag = 1;
	    }
	    
	  if((prod_priority >= postpaid_lim_start && prod_priority <= postpaid_lim_end))
	  {
	        flag = 0;
	  }
		
		if(is_autorenew_flow(connp, opstackp, ebufp) || action!=NULL) {
	    	    sprintf(msg, "called from pin_cycle_fee or billing.. calling renew quota");
	    	    PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, msg);
		    mso_cust_renew_quota(ctxp, acnt_pdp, action,service_obj, product_pdp, flag, r_flistp, ebufp);
        	}
	    }
	}
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Leaving fm_mso_update_service_fup_status");
	return;
}


int is_autorenew_flow(
		cm_nap_connection_t     *connp,
		cm_op_info_t *opstackp,
		pin_errbuf_t     *ebufp) {


    int32               stack_opcode = 0;
    pin_flist_t		*stack_flistp = NULL;
    char		*prog_name = NULL;

    char		msg[100];

    while(opstackp != NULL) 
    {
        stack_opcode = opstackp->opcode;
	stack_flistp = opstackp->in_flistp;

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,"is_autorenew_flow:Stack flist here",stack_flistp);
	prog_name = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_PROGRAM_NAME, 1, ebufp);

	if(prog_name) PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,prog_name);

	sprintf(msg,"is_autorenew_flow check :Calling previous opcode is %s",pcm_opcode_to_opname(stack_opcode));
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,msg);

        if(((stack_opcode == PCM_OP_SUBSCRIPTION_APPLY_RATE || 
	     stack_opcode == PCM_OP_SUBSCRIPTION_CYCLE_FORWARD || 
	     stack_opcode == PCM_OP_SUBSCRIPTION_CYCLE_ARREARS) 
		/*** Pavan Bellala - 28-08-2015 *********************************************
		Condition changed as the program name is "pin_cycle" and not "pin_cycle_fees
		****************************************************************************/
		//&& ((prog_name) && (strcmp(prog_name,"pin_cycle_fee")==0))) || 
		&& ((prog_name) && (strstr(prog_name,"pin_cycle")!= NULL))) || 
		(stack_opcode == PCM_OP_BILL_MAKE_BILL)) {

		if(fm_utils_op_is_ancestor(connp->coip,MSO_OP_CUST_ACTIVATE_BB_SERVICE)){
			PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,"This is service activation.Hence not renew flow");
			return 0;
		} 

    	return 1;
        }

	/**** Pavan Bellala 20-08-2015 Section commented and added for prepaid FUP Renewal *******
        if(	stack_opcode == PCM_OP_SUBSCRIPTION_APPLY_RATE || 
		stack_opcode == PCM_OP_SUBSCRIPTION_CYCLE_FORWARD || 
		stack_opcode == PCM_OP_SUBSCRIPTION_CYCLE_ARREARS || 
		((prog_name) && (strcmp(prog_name,"pin_cycle_fee")==0)) || 
		stack_opcode == PCM_OP_BILL_MAKE_BILL) {

		if(fm_utils_op_is_ancestor(connp->coip,MSO_OP_CUST_ACTIVATE_BB_SERVICE)){
			PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG,"This is service activation.Hence not renew flow");
			return 0;
		} 
    	return 1;
        }
	******/
        opstackp = opstackp->next;
    }
return 0;
}

void create_lifecycle_event(pcm_context_t		*ctxp,
		pin_flist_t		*i_flistp,
		pin_flist_t		*prod_details_flistp,
		pin_errbuf_t		*ebufp)
		
{

	char	*program = "AUTO_RENEWAL";
	char	*msg = "Automatic Renewal";
	char	*event = "/event/activity/mso_lifecycle/auto_renew";
	char	*permitted = NULL;
	double	prod_priority = 0;
	int32	flag = 6;
	int	i = 0;
	poid_t	*acct_pdp = NULL,*service_obj = NULL; 
	pin_flist_t	*read_flds_in_flistp = NULL;
	pin_flist_t	*read_flds_out_flistp = NULL;
	char	*broadband = "/service/telco/broadband";
	char	debug_msg[250];
		
	permitted = PIN_FLIST_FLD_GET(prod_details_flistp, PIN_FLD_PERMITTED, 0, ebufp);
	sprintf(debug_msg, "Permitted is %s",permitted);
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, debug_msg);
	if (strcmp(permitted, broadband) == 0)
	{		
		prod_priority = pbo_decimal_to_double( PIN_FLIST_FLD_GET(prod_details_flistp, PIN_FLD_PRIORITY, 0, ebufp),ebufp);		
		prod_priority = ((int)prod_priority%1000);

		if (prod_priority >= BB_POSTPAID_START && prod_priority <= BB_POSTPAID_END)
		{
	sprintf(debug_msg, "Comparing priorities for %d",prod_priority);
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, debug_msg);
			for(i = 0; i < 12; i++) {
				if(prod_priority == postpaid_grants_priorities[i]) {
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Found matching priorities");
					acct_pdp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_POID, 0, ebufp);
					read_flds_in_flistp = PIN_FLIST_CREATE(ebufp);
					PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_OFFERING_OBJ, read_flds_in_flistp, PIN_FLD_POID, ebufp);
					PIN_FLIST_FLD_SET(read_flds_in_flistp, PIN_FLD_SERVICE_OBJ, NULL, ebufp);
					PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, read_flds_in_flistp, &read_flds_out_flistp, ebufp);
					service_obj = PIN_FLIST_FLD_GET(read_flds_out_flistp, PIN_FLD_SERVICE_OBJ, 0, ebufp);
					//fm_mso_cust_gen_event(ctxp, acct_pdp, service_obj, program, msg, event, flag,ebufp);
				}
			}
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " Done comparing priorities");
		}
	}
	sprintf(debug_msg, "Leaving create_lifecycle_event");
	PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, debug_msg);
	return;
}

int32 get_bill_when_from_service(pcm_context_t		*ctxp,
								poid_t				*svc_pdp,
								pin_errbuf_t		*ebufp) 
{
	int32	bill_when = 0;
	pin_flist_t	*read_in_flistp = PIN_FLIST_CREATE(ebufp);
	pin_flist_t	*read_out_flistp = NULL;
	pin_flist_t	*bb_info_flistp = NULL;

	PIN_FLIST_FLD_SET(read_in_flistp, PIN_FLD_POID, svc_pdp, ebufp);
	bb_info_flistp = PIN_FLIST_ELEM_ADD(read_in_flistp, MSO_FLD_BB_INFO, 0, ebufp);
	PIN_FLIST_FLD_SET(bb_info_flistp, PIN_FLD_BILL_WHEN, NULL, ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Input flist to read bill_when from service", read_in_flistp);
	PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, read_in_flistp, &read_out_flistp, ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Output flist to read bill_when from service", read_out_flistp);
	bb_info_flistp = PIN_FLIST_ELEM_GET(read_out_flistp, MSO_FLD_BB_INFO, 0 ,0, ebufp);
	bill_when = *(int32 *) PIN_FLIST_FLD_GET(bb_info_flistp, PIN_FLD_BILL_WHEN, 0, ebufp);
	return bill_when;
}



void fm_mso_set_charged_to_t(pcm_context_t		*ctxp,
								pin_flist_t		*i_flistp,
								pin_flist_t		**r_flistpp,
								cm_op_info_t		*opstackp,
								pin_errbuf_t	*ebufp)
{
	pin_flist_t	*read_payinfo_iflist = NULL;
	pin_flist_t	*read_payinfo_oflist = NULL;
	pin_flist_t	*readproduct_inflistp = NULL;
	pin_flist_t	*readproduct_outflistp = NULL;
	pin_flist_t	*srch_in_flistp = NULL;
	pin_flist_t	*srch_out_flistp = NULL;
	pin_flist_t	*srch_billinfo_iflist = NULL;
	pin_flist_t	*srch_billinfo_oflist = NULL;
	pin_flist_t	*srch_ar_billinfo_iflist = NULL;
	pin_flist_t	*srch_ar_billinfo_oflist = NULL;
	pin_flist_t	*args_flistp = NULL;
	pin_flist_t	*result_flistp = NULL;
	pin_flist_t	*inv_info = NULL;
	pin_flist_t	*bb_info_flistp = NULL;
	char		*template = "select X from /service 1, /purchased_product 2 where 2.F1 = V1 and 1.F2 = 2.F3 ";
	int64		db = 1;
	int32		search_flags = 256;
	poid_t		*srch_pdp = NULL;
	poid_t		*product_poid = NULL;
	poid_t		*payinfo_obj = NULL;
	poid_t		*ar_billinfo_obj = NULL;
	time_t		*charged_from_t = NULL;
	time_t		charged_to_t;
	struct tm		*timeeff;
	int32		payterm = 0;
	int32		prepaid_indicator = 0;
	int32		stack_opcode=0;
	int32		hold_svc_found=0;
	char		*billinfo_id = "BB";
	pin_decimal_t		*prod_priority = NULL;
	double		prod_priority_double = 0;
	char			log_buf[255];
	char		*action = NULL;
	pin_flist_t     *stack_flistp = NULL;
	poid_t		*prod_off_pdp = NULL;	
	int32		fup_top = 0;
	pin_flist_t	*ret_flistp = NULL;	
	poid_t		*account_obj = NULL;
	poid_t		*service_obj = NULL;
	time_t		*end_t = NULL;
	pin_flist_t	*ret_flistpp = NULL;

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_set_charged_to_t input flist", i_flistp);
	// Algo
	// Read payinfo to determine if it is a prepaid service or not.
	// if not prepaid, return
	// Get priority of the product to determine the type of plan.
	// if Limited plan,
	//		get the payterm from the service and add that number of months to charged_from_t
	// if Unlimited No FUP, leave it as is.
	// if Unlimited with FUP,
	//		Add 1 month to the charged_from_t.



	// Read payinfo to determine if it is a prepaid service or not.
	srch_pdp = PIN_POID_CREATE(db, "/search", -1, ebufp);

	// Search ar_billinfo for payinfo obj..
	srch_ar_billinfo_iflist = PIN_FLIST_CREATE(ebufp);

	PIN_FLIST_FLD_PUT(srch_ar_billinfo_iflist, PIN_FLD_POID, srch_pdp, ebufp);
	PIN_FLIST_FLD_SET(srch_ar_billinfo_iflist, PIN_FLD_FLAGS, &search_flags, ebufp);
	PIN_FLIST_FLD_SET(srch_ar_billinfo_iflist, PIN_FLD_TEMPLATE, "select X from /billinfo  where F1 = V1 ", ebufp);

	args_flistp = PIN_FLIST_ELEM_ADD(srch_ar_billinfo_iflist, PIN_FLD_ARGS, 1, ebufp);
	PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_POID, args_flistp, PIN_FLD_ACCOUNT_OBJ,  ebufp);

	result_flistp = PIN_FLIST_ELEM_ADD(srch_ar_billinfo_iflist, PIN_FLD_RESULTS, 0, ebufp);
	PIN_FLIST_FLD_SET(result_flistp, PIN_FLD_AR_BILLINFO_OBJ, NULL, ebufp);

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf search billinfo input list", srch_ar_billinfo_iflist);
	PCM_OP(ctxp, PCM_OP_SEARCH, 0, srch_ar_billinfo_iflist, &srch_ar_billinfo_oflist, ebufp);
	PIN_FLIST_DESTROY_EX(&srch_ar_billinfo_iflist, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_SEARCH", ebufp);
		PIN_FLIST_DESTROY_EX(&srch_ar_billinfo_oflist, NULL);
		return;
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf search billinfo output flist", srch_ar_billinfo_oflist);

	result_flistp = PIN_FLIST_ELEM_GET(srch_ar_billinfo_oflist, PIN_FLD_RESULTS, 0, 0, ebufp);
	ar_billinfo_obj = PIN_FLIST_FLD_GET(result_flistp, PIN_FLD_AR_BILLINFO_OBJ, 0, ebufp);


	// Search billinfo for payinfo obj..
	srch_pdp = PIN_POID_CREATE(db, "/search", -1, ebufp);
	srch_billinfo_iflist = PIN_FLIST_CREATE(ebufp);

	PIN_FLIST_FLD_PUT(srch_billinfo_iflist, PIN_FLD_POID, srch_pdp, ebufp);
	PIN_FLIST_FLD_SET(srch_billinfo_iflist, PIN_FLD_FLAGS, &search_flags, ebufp);
	PIN_FLIST_FLD_SET(srch_billinfo_iflist, PIN_FLD_TEMPLATE, "select X from /billinfo  where F1.id = V1 and F2 = V2 ", ebufp);

	args_flistp = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_ARGS, 1, ebufp);
	//PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_POID, args_flistp, PIN_FLD_ACCOUNT_OBJ,  ebufp);
	PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_POID, ar_billinfo_obj, ebufp);

	args_flistp = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_ARGS, 2, ebufp);
	PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_BILLINFO_ID, billinfo_id, ebufp);

	result_flistp = PIN_FLIST_ELEM_ADD(srch_billinfo_iflist, PIN_FLD_RESULTS, 0, ebufp);
	PIN_FLIST_FLD_SET(result_flistp, PIN_FLD_PAYINFO_OBJ, NULL, ebufp);

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf search billinfo input list", srch_billinfo_iflist);
	PCM_OP(ctxp, PCM_OP_SEARCH, 0, srch_billinfo_iflist, &srch_billinfo_oflist, ebufp);
	PIN_FLIST_DESTROY_EX(&srch_billinfo_iflist, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_SEARCH", ebufp);
		PIN_FLIST_DESTROY_EX(&srch_billinfo_oflist, NULL);
		return;
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf search billinfo output flist", srch_billinfo_oflist);

	result_flistp = PIN_FLIST_ELEM_GET(srch_billinfo_oflist, PIN_FLD_RESULTS, 0, 0, ebufp);
	payinfo_obj = PIN_FLIST_FLD_GET(result_flistp, PIN_FLD_PAYINFO_OBJ, 0, ebufp);
	
	// Read payinfo object for prepaid indicator.
	read_payinfo_iflist = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_SET(read_payinfo_iflist, PIN_FLD_POID, payinfo_obj, ebufp);

	PIN_FLIST_DESTROY_EX(&srch_billinfo_oflist, NULL);
	PIN_FLIST_DESTROY_EX(&srch_ar_billinfo_oflist, NULL);
	
	PIN_FLIST_ELEM_SET(read_payinfo_iflist, NULL, PIN_FLD_INV_INFO, 0, ebufp );

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf read payinfo input list", read_payinfo_iflist);
	PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, read_payinfo_iflist, &read_payinfo_oflist, ebufp);
	PIN_FLIST_DESTROY_EX(&read_payinfo_iflist, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_READ_FLDS", ebufp);
		PIN_FLIST_DESTROY_EX(&read_payinfo_oflist, NULL);
		return;
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_modify_for_mcf read payinfo output flist", read_payinfo_oflist);

	if (read_payinfo_oflist)
	{
		inv_info = PIN_FLIST_ELEM_GET(read_payinfo_oflist, PIN_FLD_INV_INFO, 0, 1, ebufp);
		prepaid_indicator = *(int32 *)PIN_FLIST_FLD_GET(inv_info, PIN_FLD_INDICATOR, 0, ebufp);
	}

	 // Added below while loop to find if the flow is from HOLD_SERVICE.
        // For Hold service (FUP plan) do not perform this action.	
	while(opstackp != NULL)
        {
                stack_opcode = opstackp->opcode;
                stack_flistp = opstackp->in_flistp;
                sprintf(log_buf, "OPCODE=%d", stack_opcode);
                PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, log_buf);
                PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "cm_op_info_t stack input flist is ", stack_flistp);
                if (stack_opcode == MSO_OP_CUST_HOLD_SERVICE)
                {
                        hold_svc_found = 1;
                        PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Hold Service Found");
                        break;
                }
                if(stack_opcode == MSO_OP_PROV_BB_PROCESS_RESPONSE)
                {
                        action = PIN_FLIST_FLD_GET(stack_flistp, PIN_FLD_ACTION, 1, ebufp);
                        if(action &&(strstr(action, "UNHOLD_SERVICES")))
                        {
                                PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_ACTION, action, ebufp);
                        }
			//added condition to set the purchase_end_t to charged_t of fup_topup product  
                        else if(action &&(strstr(action, "UPDATE_SUBSCRIBER-FUP")))
                        {
				prod_off_pdp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_PRODUCT_OBJ, 1, ebufp);
				//to check weather product is fup topup product or not
				fup_top = fm_mso_get_product_priority(ctxp, prod_off_pdp, &ret_flistp, ebufp);
                                if (PIN_ERR_IS_ERR(ebufp))
                                {
                                        PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in after returing from fm_mso_get_product_priority", ebufp);
                                        return;
                                }
                                if(fup_top == 1)
                                {
					prod_off_pdp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_OFFERING_OBJ, 1, ebufp);
					//get the purchase_end_t
                                        fm_mso_prov_update_product_cycle_fee_charge_dates(ctxp, NULL, NULL, prod_off_pdp, &ret_flistpp, ebufp);
					if (PIN_ERR_IS_ERR(ebufp))
                                	{
                                                PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in after returing from fm_mso_prov_update_product_cycle_fee_charge_dates", ebufp);
                                        	return;
                                	}
					end_t = PIN_FLIST_FLD_GET(ret_flistpp, PIN_FLD_PURCHASE_END_T, 1, ebufp );
                                        PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_END_T, end_t, ebufp );
                                        PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_TO_T, end_t, ebufp );
                                        PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CYCLE_FEE_END_T, *r_flistpp, PIN_FLD_CYCLE_FEE_END_T, ebufp);
                                        PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CHARGED_TO_T,    *r_flistpp, PIN_FLD_CHARGED_TO_T, ebufp);	
					PIN_FLIST_DESTROY_EX(&ret_flistpp, NULL);
				}
			}
		}
                opstackp = opstackp->next;
        }

	if(prepaid_indicator != PREPAID) {
		// if not prepaid, return;
		return;
	}
	PIN_FLIST_DESTROY_EX(&read_payinfo_oflist, NULL);


	// Get priority of the product to determine the type of plan.
	product_poid = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_PRODUCT_OBJ, 1, ebufp);
	if (!product_poid)
	{	
		return;
	}	


	readproduct_inflistp = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_SET(readproduct_inflistp, PIN_FLD_POID, product_poid, ebufp );
	PIN_FLIST_FLD_SET(readproduct_inflistp, PIN_FLD_PRIORITY, 0, ebufp );

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_set_charged_to_t read product input list", readproduct_inflistp);
	PCM_OP(ctxp, PCM_OP_READ_FLDS, 0, readproduct_inflistp, &readproduct_outflistp, ebufp);
	PIN_FLIST_DESTROY_EX(&readproduct_inflistp, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error in calling PCM_OP_READ_FLDS", ebufp);
		PIN_ERR_CLEAR_ERR(ebufp);
		PIN_FLIST_DESTROY_EX(&readproduct_outflistp, NULL);	
		return;
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_set_charged_to_t read product output flist", readproduct_outflistp);
	
	prod_priority = PIN_FLIST_FLD_GET(readproduct_outflistp, PIN_FLD_PRIORITY, 0, ebufp );

	prod_priority_double = pbo_decimal_to_double(prod_priority, ebufp);

	prod_priority_double = ((int)prod_priority_double) % 1000;

	PIN_FLIST_DESTROY_EX(&readproduct_outflistp, NULL);



	// Limited
	if (prod_priority_double >= BB_LIMITED_RANGE_START &&
        prod_priority_double <= BB_LIMITED_RANGE_END) {

		// if Limited plan,
		//		get the payterm from the service and add that number of months to charged_from_t
	
		
		srch_in_flistp = PIN_FLIST_CREATE(ebufp);
		PIN_FLIST_FLD_SET(srch_in_flistp, PIN_FLD_POID, srch_pdp, ebufp);
		PIN_FLIST_FLD_SET(srch_in_flistp, PIN_FLD_FLAGS, &search_flags, ebufp);
		PIN_FLIST_FLD_SET(srch_in_flistp, PIN_FLD_TEMPLATE, template, ebufp);

		args_flistp = PIN_FLIST_ELEM_ADD(srch_in_flistp, PIN_FLD_ARGS, 1, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_OFFERING_OBJ, args_flistp, PIN_FLD_POID,ebufp );
		args_flistp = PIN_FLIST_ELEM_ADD(srch_in_flistp, PIN_FLD_ARGS, 2, ebufp);
		PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_POID, NULL, ebufp);
		args_flistp = PIN_FLIST_ELEM_ADD(srch_in_flistp, PIN_FLD_ARGS, 3, ebufp);
		PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_SERVICE_OBJ, NULL, ebufp);

		result_flistp = PIN_FLIST_ELEM_ADD(srch_in_flistp, PIN_FLD_RESULTS, 0, ebufp);
		bb_info_flistp = PIN_FLIST_SUBSTR_ADD(srch_in_flistp, MSO_FLD_BB_INFO, ebufp);
		PIN_FLIST_FLD_SET(bb_info_flistp, PIN_FLD_BILL_WHEN, NULL, ebufp);

		
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_set_charged_to_t search input flist", srch_in_flistp);
		PCM_OP(ctxp, PCM_OP_SEARCH, 0, srch_in_flistp, &srch_out_flistp, ebufp);
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "fm_mso_set_charged_to_t search output flist", srch_out_flistp);

		PIN_FLIST_DESTROY_EX(&srch_in_flistp, NULL);

		result_flistp = PIN_FLIST_ELEM_GET(srch_out_flistp, PIN_FLD_RESULTS, 0, 0, ebufp);
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "After time set 1");
		bb_info_flistp = PIN_FLIST_SUBSTR_GET(result_flistp, MSO_FLD_BB_INFO, 0, ebufp);
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "After time set 2");
		payterm = *((int32 *)PIN_FLIST_FLD_GET(bb_info_flistp, PIN_FLD_BILL_WHEN, 0, ebufp));
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "After time set 3");

		charged_from_t = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_FROM_T, 1, ebufp);




		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "After time set 4");
		timeeff = localtime(charged_from_t);
		timeeff->tm_mon = timeeff->tm_mon + payterm;
		charged_to_t = mktime (timeeff);

		PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_COUNT, &payterm, ebufp);
		PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Modified input flist", i_flistp);



		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "After time set");

		PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_TO_T, &charged_to_t, ebufp);
		PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_END_T, &charged_to_t, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CYCLE_FEE_END_T, *r_flistpp, PIN_FLD_CYCLE_FEE_END_T, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CHARGED_TO_T,    *r_flistpp, PIN_FLD_CHARGED_TO_T, ebufp);
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "After END_T set");
		PIN_FLIST_DESTROY_EX(&srch_out_flistp, NULL);
	}
	// Unlimited without FUP
	else if (prod_priority_double >= BB_UNLIMITED_NO_FUP_RANGE_START &&
        prod_priority_double <= BB_UNLIMITED_NO_FUP_RANGE_END) {
		// if Unlimited No FUP, leave it as is.
	
		return;
	}
	// Unlimited with FUP
	else if (prod_priority_double >= BB_UNLIMITED_FUP_RANGE_START &&
        prod_priority_double <= BB_UNLIMITED_FUP_RANGE_END && !hold_svc_found) {
		// if Unlimited with FUP, Add 1 month to the charged_from_t.
		//  For Hold, it should not be executed.
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Setting charged_to_t for unlimited with fup");
		charged_from_t = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_CHARGED_FROM_T, 1, ebufp);
		timeeff = localtime(charged_from_t);
		timeeff->tm_mon = timeeff->tm_mon + 1;
		charged_to_t = mktime (timeeff);
		sprintf(log_buf, "charged_from=%d; charged_to=%d", *charged_from_t,charged_to_t );
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, log_buf);
		PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CHARGED_TO_T, &charged_to_t, ebufp);
		PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_FEE_END_T, &charged_to_t, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CYCLE_FEE_END_T, *r_flistpp, PIN_FLD_CYCLE_FEE_END_T, ebufp);
		PIN_FLIST_FLD_COPY(i_flistp, PIN_FLD_CHARGED_TO_T,    *r_flistpp, PIN_FLD_CHARGED_TO_T, ebufp);

	}

	return;
}


static void mso_cust_renew_quota(pcm_context_t		*ctxp,
					poid_t		*acct_pdp,
					char		*action,
					poid_t		*svc_pdp,
					poid_t		*product_pdp, //added new field
					int32             flag,
					pin_flist_t	*r_flistp,
					pin_errbuf_t		*ebufp) 
{
	//DOC_BB_AUTO_RENEW_POST

	pin_flist_t	*mso_pp_in_flistp = NULL;
	pin_flist_t	*mso_pp_out_flistp = NULL;
	pin_flist_t	*prov_in_flistp = NULL;
	pin_flist_t	*prov_out_flistp = NULL;
	pin_flist_t	*args_flistp = NULL;
	pin_flist_t	*result_flistp = NULL;
	char mso_pp_srch_template[200] = "select X from /mso_purchased_plan where F1 = V1 and ( F2 = V2 or F3 = V3 or F5 = V5 ) and F4 = V4 ";
	int32	active_status = 2;
	char	*base_plan_str = "base plan";
	int32	renew_post_flag = DOC_BB_AUTO_RENEW_POST;
	char	*program_name = "pin_cycle_fee";
	int32	srch_flag = 0;
	poid_t	*srch_pdp = NULL;
	poid_t	*mso_pp_pdp = NULL;
	int64	db = 1;
	int32	susp_status = 5;
	int32   inprog_status = 1;
	
    	mso_pp_in_flistp = PIN_FLIST_CREATE(ebufp);
    	srch_pdp = PIN_POID_CREATE(db, "/search", 0, ebufp);
    	PIN_FLIST_FLD_SET(mso_pp_in_flistp, PIN_FLD_POID, srch_pdp, ebufp);
    	PIN_FLIST_FLD_SET(mso_pp_in_flistp, PIN_FLD_FLAGS, &srch_flag, ebufp);
    	PIN_FLIST_FLD_SET(mso_pp_in_flistp, PIN_FLD_TEMPLATE, mso_pp_srch_template, ebufp);
    	args_flistp = PIN_FLIST_ELEM_ADD(mso_pp_in_flistp, PIN_FLD_ARGS, 1, ebufp);
    	PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_ACCOUNT_OBJ, acct_pdp, ebufp);
	args_flistp = PIN_FLIST_ELEM_ADD(mso_pp_in_flistp, PIN_FLD_ARGS, 2, ebufp);
    	PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_STATUS, &active_status, ebufp);
	args_flistp = PIN_FLIST_ELEM_ADD(mso_pp_in_flistp, PIN_FLD_ARGS, 3, ebufp);
        PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_STATUS, &susp_status, ebufp);
	args_flistp = PIN_FLIST_ELEM_ADD(mso_pp_in_flistp, PIN_FLD_ARGS, 4, ebufp);
    	PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_DESCR, base_plan_str, ebufp);
	args_flistp = PIN_FLIST_ELEM_ADD(mso_pp_in_flistp, PIN_FLD_ARGS, 5, ebufp);
        PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_STATUS, &inprog_status, ebufp);
	result_flistp = PIN_FLIST_ELEM_ADD(mso_pp_in_flistp, PIN_FLD_RESULTS, 0, ebufp);
    	PIN_FLIST_FLD_SET(result_flistp, PIN_FLD_DESCR, NULL, ebufp);

    	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "mso_cust_renew_quota search input flist for base plan search", mso_pp_in_flistp);
    	PCM_OP(ctxp, PCM_OP_SEARCH, 0, mso_pp_in_flistp, &mso_pp_out_flistp, ebufp);
    	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "mso_cust_renew_quota search output flist for base plan search", mso_pp_out_flistp);

    	result_flistp = PIN_FLIST_ELEM_GET(mso_pp_out_flistp, PIN_FLD_RESULTS, 0, 0, ebufp);

	if(result_flistp == NULL) {
		PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, " No base plan exists for this, which is surprising. Bailing out... ");
		goto cleanup;
	}
	mso_pp_pdp = PIN_FLIST_FLD_GET(result_flistp, PIN_FLD_POID, 0, ebufp);
	if(flag == 1)
	{
           renew_post_flag = DOC_BB_FUP_REVERSAL;
	}
	prov_in_flistp = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_SET(prov_in_flistp, PIN_FLD_POID, acct_pdp, ebufp);
	PIN_FLIST_FLD_SET(prov_in_flistp, PIN_FLD_SERVICE_OBJ, svc_pdp, ebufp);
	PIN_FLIST_FLD_SET(prov_in_flistp, PIN_FLD_FLAGS, &renew_post_flag, ebufp);
	PIN_FLIST_FLD_SET(prov_in_flistp, MSO_FLD_PURCHASED_PLAN_OBJ, mso_pp_pdp, ebufp);
	PIN_FLIST_FLD_SET(prov_in_flistp, PIN_FLD_PROGRAM_NAME, program_name, ebufp);
	PIN_FLIST_FLD_SET(prov_in_flistp, PIN_FLD_USERID, acct_pdp, ebufp);
	PIN_FLIST_FLD_SET(prov_in_flistp, PIN_FLD_PRODUCT_OBJ, product_pdp, ebufp);
	if(action)
	{
		PIN_FLIST_FLD_SET(prov_in_flistp, PIN_FLD_ACTION, action, ebufp);
	}
	PIN_FLIST_FLD_COPY(r_flistp, PIN_FLD_CHARGED_FROM_T, prov_in_flistp, PIN_FLD_CHARGED_FROM_T, ebufp);
	PIN_FLIST_FLD_COPY(r_flistp, PIN_FLD_CHARGED_TO_T, prov_in_flistp, PIN_FLD_CHARGED_TO_T, ebufp);

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "MSO_OP_PROV_CREATE_ACTION input flist", prov_in_flistp);
    	PCM_OP(ctxp, MSO_OP_PROV_CREATE_ACTION, 0, prov_in_flistp, &prov_out_flistp, ebufp);
    	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "MSO_OP_PROV_CREATE_ACTION output flist", prov_out_flistp);


cleanup:
		PIN_FLIST_DESTROY_EX(&mso_pp_in_flistp, NULL);
		PIN_FLIST_DESTROY_EX(&mso_pp_out_flistp, NULL);
		PIN_FLIST_DESTROY_EX(&prov_in_flistp, NULL);
		PIN_FLIST_DESTROY_EX(&prov_out_flistp, NULL);

}


/* AMC CHANGES */

/**********************************************
 * Search service for the mso_purchased_plan 
 * Entries and get subscription Details  
 *********************************************/

static  void
fm_mso_cust_bb_hw_amc_get_cycle_details(
        pcm_context_t   *ctxp,
        pin_flist_t      *i_flistp,
        pin_errbuf_t    *ebufp)
{


        pin_flist_t     *args_flistp = NULL;
        pin_flist_t     *search_inflistp = NULL;
        pin_flist_t     *search_outflistp = NULL;
        pin_flist_t     *results_flistp = NULL;
        pin_flist_t     *services_flistp = NULL;
	pin_flist_t     *subs_outflistp = NULL;

        char            *device_id = NULL;
        char            search_template[100] = " select X from /mso_purchased_plan where F1 = V1 and F2 = V2 ";
        int             search_flags = 768;
        int64           db = 1;
        int             elem_id = 0;
        pin_cookie_t    pcookie = NULL;
	int             pelem_id = 0;
        pin_cookie_t    cookie = NULL;
        poid_t          *service_pdp = NULL;
	poid_t          *a_pdp = NULL;
        pin_flist_t     *s_flistp = NULL;
	int32		subs_found = 0;
	poid_t		*subs_pdp = NULL;
	char		*prov_tag = NULL;
	pin_flist_t	*products_flistp = NULL;
	int32 		*p_status = NULL;
	time_t		*cycle_end_t = NULL;
	pin_flist_t     *res_flistp = NULL;
	pin_flist_t 	*pr_flistp = NULL;
	pin_flist_t	*cycle_flistp = NULL;
	poid_t		*p_pdp = NULL;
	int		inr = 356;
	char		*plan_type = "base plan";
	
		

        if (PIN_ERR_IS_ERR(ebufp))
		return;
                
	PIN_ERR_CLEAR_ERR(ebufp);

    	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
                        "fm_mso_cust_bb_hw_amc_get_cycle_details input flist", i_flistp);

	a_pdp = PIN_FLIST_FLD_GET(i_flistp, PIN_FLD_POID, 0, ebufp);
	

        /*************
         * search flist to search device details based on service poid
         ************/
        if (PIN_ERR_IS_ERR(ebufp))
        {
                //On Error
                PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_ERROR,
                                "Subscription product Error preparation", search_inflistp);
                PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error calling Subscription search", ebufp);
                return;

        }


	db = PIN_POID_GET_DB(a_pdp);

        search_inflistp = PIN_FLIST_CREATE(ebufp);
        PIN_FLIST_FLD_PUT(search_inflistp, PIN_FLD_POID, PIN_POID_CREATE(db, "/search", -1, ebufp), ebufp);
        PIN_FLIST_FLD_SET(search_inflistp, PIN_FLD_FLAGS, &search_flags, ebufp);
        PIN_FLIST_FLD_SET(search_inflistp, PIN_FLD_TEMPLATE, search_template, ebufp);
        args_flistp = PIN_FLIST_ELEM_ADD(search_inflistp, PIN_FLD_ARGS, 1, ebufp);
        PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_ACCOUNT_OBJ, a_pdp, ebufp);
	args_flistp = PIN_FLIST_ELEM_ADD(search_inflistp, PIN_FLD_ARGS, 2, ebufp);
	PIN_FLIST_FLD_SET(args_flistp, PIN_FLD_DESCR, plan_type, ebufp);
        results_flistp = PIN_FLIST_ELEM_ADD(search_inflistp, PIN_FLD_RESULTS, 0, ebufp);
        PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
                        "search mso_purchased_plan input list", search_inflistp);

        if (PIN_ERR_IS_ERR(ebufp)) 
        {
                //On Error
                PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_ERROR,
                                "Subscription product Error preparation", search_inflistp);
                PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error calling Subscription search", ebufp);
                PIN_FLIST_DESTROY_EX(&search_outflistp, NULL);
                PIN_FLIST_DESTROY_EX(&search_inflistp, NULL);
                return;

        }


        PCM_OP(ctxp, PCM_OP_SEARCH, 0, search_inflistp, &search_outflistp, ebufp);

        if (PIN_ERR_IS_ERR(ebufp) || search_outflistp == NULL)
        {
            //On Error
        	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_ERROR,
				"search input list Subscription search", search_inflistp);
        	PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error calling Subscription Search", ebufp);
        	PIN_FLIST_DESTROY_EX(&search_outflistp, NULL);
		PIN_FLIST_DESTROY_EX(&search_inflistp, NULL);
		return;
				
	}	

        PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
                                "Subscription Search", search_outflistp);
         /*search Through the results and get the product which has Prov Tag */
	while ((results_flistp =   
				PIN_FLIST_ELEM_GET_NEXT(search_outflistp, PIN_FLD_RESULTS,
                               &elem_id, 1, &cookie, ebufp)) != NULL)
        {
		p_status = PIN_FLIST_FLD_GET(results_flistp, PIN_FLD_STATUS , 1, ebufp);
		products_flistp = NULL;
		pelem_id = 0;
		pcookie = NULL;
		if(subs_found)
			break;
		if(p_status && (*p_status == MSO_PROV_ACTIVE || *p_status == MSO_PROV_IN_PROGRESS || *p_status == MSO_PROV_SUSPEND))
		{		
			while ((products_flistp =   
				PIN_FLIST_ELEM_GET_NEXT(results_flistp, PIN_FLD_PRODUCTS,
                              		&pelem_id, 1, &pcookie, ebufp)) != NULL)
			{
				prov_tag = (char *)PIN_FLIST_FLD_GET(products_flistp, PIN_FLD_PROVISIONING_TAG, 1, ebufp);
				PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Inside PROV TAG SEARCH", products_flistp);
				if(prov_tag && strlen(prov_tag)>0 )
		
				{
					subs_found = 1;
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "FOUND SUBS PRODUCT");
					subs_pdp = PIN_FLIST_FLD_GET(products_flistp, MSO_FLD_PURCHASED_PRODUCT_OBJ, 0, ebufp);
					break;
				}
			}
              

        	}
	}
		
		
	if (PIN_ERR_IS_ERR(ebufp) || subs_found == 0 ) 
        {
            	//On Error
            	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_ERROR,
				"Subscription product search error", search_inflistp);
            	PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error calling Subscription search", ebufp);
            	PIN_FLIST_DESTROY_EX(&search_outflistp, NULL);
		PIN_FLIST_DESTROY_EX(&search_inflistp, NULL);
		return;
				
	}	
		
	/*get cycle details of product */
	PIN_FLIST_DESTROY_EX(&search_inflistp, NULL);
	search_inflistp = PIN_FLIST_CREATE(ebufp);
		
	PIN_FLIST_FLD_SET(search_inflistp, PIN_FLD_POID, subs_pdp,ebufp);
		
	PCM_OP(ctxp, PCM_OP_READ_OBJ , 0, search_inflistp, &subs_outflistp, ebufp);
		
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
                                "Read Subs Product Output", subs_outflistp);
								
	if (PIN_ERR_IS_ERR(ebufp) || subs_outflistp == NULL)
        {
            //On Error
            PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_ERROR,
				"Error in reading subs product", search_inflistp);
        	PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error read obj of subscription", ebufp);
        	PIN_FLIST_DESTROY_EX(&search_outflistp, NULL);
		PIN_FLIST_DESTROY_EX(&subs_outflistp, NULL);
		PIN_FLIST_DESTROY_EX(&search_inflistp, NULL);
		return;
				
	}

	p_pdp = PIN_FLIST_FLD_GET(subs_outflistp, PIN_FLD_PRODUCT_OBJ, 0, ebufp); 
	//IF CYCLE Array Present get charged_to_t 
	if(PIN_FLIST_ELEM_COUNT(subs_outflistp, PIN_FLD_CYCLE_FEES, ebufp))
	{
		cycle_flistp = PIN_FLIST_ELEM_GET(subs_outflistp, PIN_FLD_CYCLE_FEES, PIN_ELEMID_ANY, 1, ebufp);
		cycle_end_t = PIN_FLIST_FLD_GET(cycle_flistp, PIN_FLD_CHARGED_TO_T, 0, ebufp);
	}
	else // set cycle_end_t as charged_to_t of subscription
	{
		cycle_end_t = PIN_FLIST_FLD_GET(subs_outflistp, PIN_FLD_CYCLE_END_T, 0, ebufp);
	}

        if (PIN_ERR_IS_ERR(ebufp)) 
        {
            //On Error
            PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_ERROR,
                                "cannot Read SUBS PRODUCT CYCLE DATES ", search_inflistp);
                PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error read obj of subscription", ebufp);
                PIN_FLIST_DESTROY_EX(&search_outflistp, NULL);
                PIN_FLIST_DESTROY_EX(&search_inflistp, NULL);
		PIN_FLIST_DESTROY_EX(&subs_outflistp, NULL);
                return;

        }
	PIN_FLIST_FLD_SET(i_flistp, PIN_FLD_CYCLE_END_T, cycle_end_t, ebufp);
	/*pr_flistp = PIN_FLIST_ELEM_ADD(res_flistp, PIN_FLD_BAL_IMPACTS, 0, ebufp);
	PIN_FLIST_FLD_SET(pr_flistp, PIN_FLD_RESOURCE_ID, &inr, ebufp); */

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG,
				"Modified Input Flist is ", i_flistp);

		
	PIN_FLIST_DESTROY_EX(&search_inflistp, NULL);
	PIN_FLIST_DESTROY_EX(&subs_outflistp, ebufp);
	//PIN_FLIST_DESTROY_EX(&search_outflistp, NULL);
        return;
}

static void
get_last_plan_valid_to_fup(
	pcm_context_t           *ctxp,
	poid_t                  *acc_obj,
	poid_t                  *svc_obj,
	time_t			*fup_valid_to,
	pin_errbuf_t            *ebufp)
{
	pin_flist_t             *srch_iflistp = NULL;
	pin_flist_t             *srch_oflistp = NULL;
	pin_flist_t             *r_i_flistp = NULL;
	pin_flist_t             *r_o_flistp = NULL;
	pin_flist_t             *args_flist = NULL;
	pin_flist_t             *res_flistp = NULL;
	pin_flist_t             *bal_flistp = NULL;
	pin_flist_t             *sub_bal_flistp = NULL;
	pin_flist_t             *prod_flistp = NULL;
	int32                   srch_flag = 0;
	char                    *s_template = "select X from /mso_purchased_plan where F1 = V1 and F2 = V2 and F3 = V3 order by mod_t desc ";

	poid_t                  *pdp = NULL;
	poid_t                  *pp_obj = NULL;
	poid_t                  *grantor_obj = NULL;
	poid_t                  *bal_grp_obj = NULL;
	int32			status = 0;
	int32			bal_elem_id = 0;
	int32			sub_bal_id = 0;
	int32			elem_id = 0;
	int32			bal_flags = 0;
	void			*vp = NULL;
	time_t			current_t;

	pin_cookie_t		cookie = NULL;
	pin_cookie_t		bal_cookie = NULL;
	pin_cookie_t		sub_cookie = NULL;

	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "Error before calling get_last_plan_valid_to_fup", ebufp);
		return;
	}
	*fup_valid_to = 0;
	// 1.Find the latest cancelled plan with given plan_obj since it is topup flow.
	status = MSO_PROV_TERMINATE;
	srch_iflistp = PIN_FLIST_CREATE(ebufp);
	pdp = PIN_POID_CREATE(1, "/search", -1, ebufp);
	PIN_FLIST_FLD_PUT(srch_iflistp, PIN_FLD_POID, pdp, ebufp);
	PIN_FLIST_FLD_SET(srch_iflistp, PIN_FLD_FLAGS, &srch_flag, ebufp);
	PIN_FLIST_FLD_SET(srch_iflistp, PIN_FLD_TEMPLATE, s_template, ebufp);

	args_flist = PIN_FLIST_ELEM_ADD(srch_iflistp, PIN_FLD_ARGS, 1, ebufp );
	PIN_FLIST_FLD_SET(args_flist, PIN_FLD_SERVICE_OBJ, svc_obj, ebufp);
	
	args_flist = PIN_FLIST_ELEM_ADD(srch_iflistp, PIN_FLD_ARGS, 2, ebufp );
	PIN_FLIST_FLD_SET(args_flist, PIN_FLD_DESCR, "base plan", ebufp);

	args_flist = PIN_FLIST_ELEM_ADD(srch_iflistp, PIN_FLD_ARGS, 3, ebufp );
	PIN_FLIST_FLD_SET(args_flist, PIN_FLD_STATUS, &status, ebufp);

	PIN_FLIST_ELEM_SET(srch_iflistp, NULL, PIN_FLD_RESULTS, PIN_ELEMID_ANY, ebufp );
	//PIN_FLIST_FLD_SET(args_flist, PIN_FLD_POID, NULL, ebufp);

	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "get_last_plan_valid_to_fup search input", srch_iflistp);
	PCM_OP(ctxp, PCM_OP_SEARCH, 0, srch_iflistp, &srch_oflistp, ebufp);
	PIN_FLIST_DESTROY_EX(&srch_iflistp, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, 
			"get_last_plan_valid_to_fup - Error in calling SEARCH", ebufp);
		return;
	}
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, 
		"get_last_plan_valid_to_fup search output", srch_oflistp);
	// Fetch the first element in search output.
	res_flistp = PIN_FLIST_ELEM_GET(srch_oflistp, PIN_FLD_RESULTS, 0, 0, ebufp );

	// Read balance group form service
	r_i_flistp = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_SET(r_i_flistp, PIN_FLD_POID, svc_obj, ebufp);
	PIN_FLIST_FLD_SET(r_i_flistp, PIN_FLD_BAL_GRP_OBJ, bal_grp_obj, ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Read Flds input flist", r_i_flistp);
	PCM_OP(ctxp, PCM_OP_READ_FLDS , 0, r_i_flistp, &r_o_flistp, ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Read Flds output flist", r_o_flistp);
	PIN_FLIST_DESTROY_EX(&r_i_flistp, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "get_last_plan_valid_to_fup - Error in calling READ_FLDS", ebufp);
		return;
	}
	bal_grp_obj = PIN_FLIST_FLD_TAKE(r_o_flistp, PIN_FLD_BAL_GRP_OBJ, 0, ebufp);
	PIN_FLIST_DESTROY_EX(&r_o_flistp, NULL);

	// 2. Find the FUP sub balance that was granted by cancelled plan (grant product)
	//	The validity of this sub balance will be extended during topup as 
	//	existing + 1month. So the newly granted sub bal must have same validity.
	r_i_flistp = PIN_FLIST_CREATE(ebufp);
	PIN_FLIST_FLD_SET(r_i_flistp, PIN_FLD_POID, acc_obj, ebufp);
	PIN_FLIST_FLD_PUT(r_i_flistp, PIN_FLD_BAL_GRP_OBJ, bal_grp_obj, ebufp);
	bal_flags = PIN_BAL_GET_ALL_BARE_RESULTS;
	current_t=pin_virtual_time ((time_t *) NULL);
	PIN_FLIST_FLD_SET(r_i_flistp, PIN_FLD_FLAGS, &bal_flags, ebufp);
	PIN_FLIST_FLD_SET(r_i_flistp, PIN_FLD_END_T, &current_t, ebufp);
	PIN_FLIST_ELEM_SET(r_i_flistp, NULL, PIN_FLD_BALANCES, PIN_ELEMID_ANY, ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Read balance group input list", r_i_flistp);
	PCM_OP(ctxp, PCM_OP_BAL_GET_BALANCES , 0, r_i_flistp, &r_o_flistp, ebufp);
	PIN_ERR_LOG_FLIST(PIN_ERR_LEVEL_DEBUG, "Read balance group output list", r_o_flistp);
	PIN_FLIST_DESTROY_EX(&r_i_flistp, NULL);
	if (PIN_ERR_IS_ERR(ebufp))
	{
		PIN_ERR_LOG_EBUF(PIN_ERR_LEVEL_ERROR, "get_last_plan_valid_to_fup - Error in calling BAL_GET_BALANCES", ebufp);
		return;
	}

	while ((bal_flistp = PIN_FLIST_ELEM_GET_NEXT(r_o_flistp, PIN_FLD_BALANCES, 
			&bal_elem_id, 1, &bal_cookie, ebufp)) != NULL)
	{
		if (bal_elem_id != MSO_FUP_TRACK )
		{
				PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Non an FUP resource");
				continue;
		}
		// Loop through each sub balance of FUP resource.
		sub_cookie = NULL;
		while ((sub_bal_flistp = PIN_FLIST_ELEM_GET_NEXT(bal_flistp, PIN_FLD_SUB_BALANCES, 
			&sub_bal_id, 1, &sub_cookie, ebufp )) != NULL)
		{
			grantor_obj = PIN_FLIST_FLD_GET(sub_bal_flistp, PIN_FLD_GRANTOR_OBJ, 0, ebufp);
			PIN_ERR_LOG_POID(PIN_ERR_LEVEL_DEBUG, "Grantor Obj :",grantor_obj);
			cookie = NULL;
			while ((prod_flistp = PIN_FLIST_ELEM_GET_NEXT(res_flistp, PIN_FLD_PRODUCTS, 
					&elem_id, 1, &cookie, ebufp)) != NULL)
			{
				pp_obj = PIN_FLIST_FLD_GET(prod_flistp, MSO_FLD_PURCHASED_PRODUCT_OBJ, 0, ebufp );
				PIN_ERR_LOG_POID(PIN_ERR_LEVEL_DEBUG, "Pur Prod Obj :",pp_obj);
				if(PIN_POID_COMPARE(grantor_obj, pp_obj, 0, ebufp)==0)
				{
					PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Poid matched...");
					vp = PIN_FLIST_FLD_GET(sub_bal_flistp, PIN_FLD_VALID_TO, 0, ebufp);
					if(vp) 
					{
						PIN_ERR_LOG_MSG(PIN_ERR_LEVEL_DEBUG, "Assigning valid to..");
						*fup_valid_to = *(time_t *)vp;
					}
				}
			}
		}
	}
	PIN_FLIST_DESTROY_EX(&srch_oflistp, NULL);
}
